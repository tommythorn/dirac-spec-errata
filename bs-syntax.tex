
%\lstset{language=Python,basicstyle=\ttfamily,keywordstyle=\rmfamily\underline}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sequence}


%\bsIF{}
%\bsEND
%\bsELSE
%\bsELSEIF{}
%\bsWHILE{}
%\bsFOREACH{}{}
%\bsFOR{}{}
%\bsRET{}

%\bsCODE{}
%\item{}{}

\begin{pseudo}{sequence}{}
\bsCODE{i = 0}
\bsWHILE{true}
 \bsCODE{seq[i] = parse\_unit()}
 \bsIF{seq[i].type == EndOfSequence}
  \bsRET{seq}%\bsEND
 \bsCODE{i = i + 1}
 \bsEND
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Parse unit}

\begin{pseudo}{parse\_unit}{}
\bsCODE{pu[type] = read\_parse\_info()}
\bsIF{pu[type] == AccessUnitHdr}
 \bsCODE{pu[data] = read\_access\_unit\_header()}
\bsELSEIF{pu[type] == Picture}
 \bsCODE{pu[data] = read\_picture()}
 \bsEND
\bsRET{pu}
\end{pseudo}


\begin{pseudo}{parse\_info}{}
\bsCODE{bytealign()}
\bsITEM{\ParseInfoPrefix}{be(4)}{}
\bsITEM{\ParseCode}{be(1)}{}
\bsITEM{\NextParseOffset}{be(3)}{}
\bsITEM{\PrevParseOffset}{be(3)}{}
\bsRET{\ParseCode}
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access unit}

[This probably has to change. TJD]

\begin{pseudo}{access\_unit\_header}{}
\bsCODE{bytealign()}
\bsCODE{read\_parse\_parameters()}
\bsCODE{read\_sequence\_parameters()}
\bsCODE{read\_display\_parameters()}
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access unit parse parameters}

\begin{pseudo}{parse\_parameters}{}
\bsITEM{\AUFrameNumber}{be(4)}{}
\bsITEM{\VersionMajor}{unsigned}{}
\bsITEM{\VersionMinor]}{unsigned}{}
\bsITEM{\Profile}{unsigned}{}
\bsITEM{\Level}{unsigned}{}

\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access unit sequence parameters}

The AU sequence parameters consist of the video format, the
image dimensions, the chroma format and the video depth. Default values are
set accoding to the video format defaults (Appendix ??).


\begin{pseudo}{sequence\_parameters}{}
\bsITEM{\VideoFormat}{unsigned}{}
\bsCODE{custom\_image\_size()}
\bsCODE{unusual\_chroma\_format()}
\bsCODE{set\_chroma_dimensions()}
\bsCODE{custom\_video\_depth()}
\end{pseudo}

[Need to work out how this fits ...]
\begin{pseudo}{custom\_image\_size}{}
\bsITEM{\CustomImageSize}{boolean}{}
\bsIF{\CustomImageSize}
 \bsITEM{\LumaWidth}{unsigned}{}
 \bsITEM{\LumaHeight}{unsigned}{}
\bsEND
\end{pseudo}

The chroma format is decoded as follows. Available formats are blah blah ... {TBC]

\begin{pseudo}{unusual\_chroma\_format}{}
\bsITEM{\UnusualChromaFormat}{boolean}{}
\bsIF{\UnusualChromaFormat}
 \bsITEM{\ChromaFormatIndex}{unsigned}{}
 \bsEND
\bsCODE{set\_chroma\_dimensions()}
\end{pseudo}

Chroma dimensions are set according to the scaling implied by the chroma format:

\begin{pseudo}{set\_chroma\_dims}{}
[TBC]
\end{pseudo}



\begin{pseudo}{custom\_video\_depth}{}
\bsITEM{\CustomVideoDepth}{boolean}{}
\bsIF{\CustomVideoDepth}
 \bsITEM{\VideoDepthValue}{unsigned}{}
 \bsEND
\end{pseudo}



%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Access unit source parameters}

\begin{pseudo}{source\_parameters}{}
\bsCODE{unusual\_scan\_format()}
\bsCODE{custom\_frame\_rate()}
\bsCODE{custom\_aspect\_ratio()}
\bsCODE{custom\_clean\_area()}
\bsCODE{custom\_signal\_range()}
\bsCODE{unusual\_colour\_spec()}
\bsRET{sp}
\end{pseudo}
\annotate{df}{replace colour\_spec with colourimetry?}

\begin{pseudo}{unusual\_scan\_format}{}
\bsITEM{\UnusualScanFormat}{boolean}{}
\bsIF{\UnusualScanFormat}
 \bsITEM{\Interlaced}{boolean}{}
 \bsIF{\Interlaced}
  \bsITEM{\UnusualFieldDominance}{boolean}{}
  \bsIF{\UnusualFieldDominance}
   \bsITEM{\TopFieldFirst}{boolean}{}
   \bsEND
  \bsITEM{\UnusualFieldInterleaving}{boolean}{}
  \bsIF{\UnusualFieldInterleaving}
   \bsITEM{\SequentialFields}{boolean}{}
   \bsEND
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{custom\_frame\_rate}{}
\bsITEM{\CustomFrameRate}{boolean}{}
\bsIF{\CustomFrameRate}
 \bsITEM{\FrameRateIndex}{unsigned}{}
 \bsIF{\FrameRateIndex == 0}
  \bsITEM{\FrameRateNumerator}{unsigned}{}
  \bsITEM{\FrameRateDenominator}{unsigned}{}
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{custom\_aspect\_ratio}{}
\bsITEM{\CustomAspectRatio}{boolean}{}
\bsIF{\CustomAspectRatio}
 \bsITEM{\AspectRatioIndex}{unsigned}{}
 \bsIF{\AspectRatioIndex == 0}
  \bsITEM{\AspectRatioNumerator}{unsigned}{}
  \bsITEM{\AspectRatioDenominator}{unsigned}{}
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{custom\_clean\_area}{}
\bsITEM{\CustomCleanArea}{boolean}{}
\bsIF{\CustomCleanArea}
 \bsITEM{\CleanWidth}{unsigned}{}
 \bsITEM{\CleanHeight}{unsigned}{}
 \bsITEM{\LeftOffset}{unsigned}{}
 \bsITEM{\TopOffset}{unsigned}{}
 \bsEND

\end{pseudo}

\begin{pseudo}{custom\_signal\_range}{}
\bsITEM{\CustomSignalRange}{boolean}{}
\bsIF{\CustomSignalRange}
 \bsITEM{\SignalRangeIndex}{unsigned}{}
 \bsIF{\SignalRangeIndex == 0}
  \bsITEM{\LumaOffset}{unsigned}{}
  \bsITEM{\LumaExcursion}{unsigned}{}
  \bsITEM{\ChromaOffset}{unsigned}{}
  \bsITEM{\ChromaExcursion}{unsigned}{}
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{unusual\_colour\_spec}{}
\bsITEM{\UnusualColourSpec}{boolean}{}
\bsIF{\UnusualColourSpec}
 \bsITEM{\ColourSpecIndex}{unsigned}{}
 \bsIF{\ColourSpecIndex] == 0}
  \bsITEM{\UnusualColourPrimaries}{boolean}{}
  \bsIF{\UnusualColourPrimaries}
   \bsITEM{\ColourPrimariesIndex}{unsigned}{}
   \bsEND
  \bsITEM{\UnusualColourMatrix}{boolean}{}
  \bsIF{\UnusualColourMatrix}
   \bsITEM{\ColourMatrixIndex}{unsigned}{}
   \bsEND
  \bsITEM{\UnusualTransferFunction}{boolean}{}
  \bsIF{\UnusualTransferFunction}
   \bsITEM{\TransferFunctionIndex}{unsigned}{}
   \bsEND
  \bsEND
 \bsEND
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Picture}

\begin{pseudo}{picture\_header}{}
\bsCODE{bytealign()}
\bsITEM{\PictureNumberOffset}{signed}{}
\bsIF{\textit{is\_inter}}
 \bsCODE{reference\_picture\_numbers()}
 \bsEND
\bsCODE{retired\_picture\_list()}

\end{pseudo}

\begin{pseudo}{reference\_picture\_numbers}{}
\bsITEM{\RefOffsetA}{signed}{}
\bsIF{\textit{num\_refs} == 2}[Has this been defined??]
 \bsITEM{\RefOffsetB}{signed}{}
 \bsEND

\end{pseudo}

\begin{pseudo}{retired\_picture\_list}{}
\bsITEM{\NumRetiredPictures}{unsigned}{}
\bsFOR{i = 0}{\NumRetiredPictures - 1}
 \bsITEM{\RetiredPictureOffset[i]}{signed}{}
 \bsEND

\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Picture prediction}

\begin{pseudo}{picture\_prediction}{}
\bsCODE{picture\_prediction\_parameters()}
\bsITEM{\BlockDataLength]}{unsigned}{}
\bsCODE{bytealign()}
\bsITEM{\CompressedBlockData]}{chunk}{}[We don't want to do this now - arithmetic decoding is at parsing level]
%    compressed\_block\_data = read\_chunk(block\_data\_length)
\end{pseudo}

\begin{pseudo}{picture\_prediction\_parameters}{}
\bsCODE{custom\_block\_parameters()}
\bsCODE{motion\_vector\_precision()}
\bsCODE{global\_motion()}
\bsCODE{custom\_picture\_prediction\_mode()}
\bsCODE{picture\_weights()}
\end{pseudo}

\begin{pseudo}{block\_parameters}{}
\bsITEM{\CustomBlockParameters}{boolean}{}
\bsIF{\CustomBlockParameters}
 \bsITEM{\BlockParametersIndex}{unsigned}{}
 \bsIF{\BlockParametersIndex == 0}
  \bsITEM{\LumaXBLen}{unsigned}{}
  \bsITEM{\LumaYBLen}{unsigned}{}
  \bsITEM{\LumaXBSep}{unsigned}{}
  \bsITEM{\LumaYBSep}{unsigned}{}
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{custom\_motion\_vector\_precision}{}
\bsITEM{\CustomMotionVectorPrecision}{boolean}{}
\bsIF{\CustomMotionVectorPrecision}
 \bsITEM{\MotionVectorPrecision}{unsigned}{}
 \bsEND
\end{pseudo}

\begin{pseudo}{global\_motion}{}
\bsITEM{\UsingGlobalMotionFlag}{boolean}{}
\bsIF{\UsingGlobalMotionFlag}
 \bsITEM{\GlobalMotionOnlyFlag}{boolean}{}
 \bsCODE{global\_motion\_parameters()}
 \bsIF{\textit{num\_refs} == 2}
  \bsCODE{global\_motion\_parameters()}
  \bsEND
 \bsEND
\end{pseudo}

\begin{pseudo}{custom\_picture\_prediction\_mode}{}
\bsITEM{\CustomPicturePredictionMode}{boolean}{}
\bsIF{\CustomPicturePredictionMode}
 \bsITEM{\PicturePredictionModeIndex}{unsigned}{}
 \bsEND

\end{pseudo}

\begin{pseudo}{custom\_picture\_weights}{}
\bsITEM{\CustomReferenceWeights}{boolean}{}
\bsIF{\CustomReferenceWeights}
 \bsITEM{\PictureWeightBits}{unsigned}{}
 \bsITEM{\PictureWeightRefA}{signed}{}
 \bsIF{\textit{num\_refs} == 2}
  \bsITEM{\PictureWeightRefB}{signed}{}
  \bsEND
 \bsEND
\end{pseudo}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Global motion parameters}

\begin{pseudo}{global\_motion\_parameters}{}
\bsCODE{pan\_tilt()}
\bsCODE{zoom\_rotate\_sheer()}
\bsCODE{perspective()}
\end{pseudo}

\begin{pseudo}{pan\_tilt}{}
\bsITEM{\NonZeroPanTiltFlag}{boolean}{}
\bsIF{\NonZeroPanTiltFlag}
 \bsITEM{\GMpan}{signed}{}
 \bsITEM{\GMtilt}{signed}{}
 \bsEND

\end{pseudo}

\begin{pseudo}{zoom\_rotation\_shear}{}
\bsITEM{\NonZeroZRSFlag}{boolean}{}
\bsIF{\NonZeroZRSFlag}
 \bsITEM{\ZRSexponent}{unsigned}{}
 \bsITEM{\GMaTL}{signed}{}
 \bsITEM{\GMaTR}{signed}{}
 \bsITEM{\GMaBL}{signed}{}
 \bsITEM{\GMaTR}{signed}{}
 \bsEND

\end{pseudo}

\begin{pseudo}{perspective}{}
\bsITEM{\NonZeroPerspectiveFlag}{boolean}{}
\bsIF{\NonZeroPerspectiveFlag}
 \bsITEM{\GMperspectiveExponent}{unsigned}{}
 \bsITEM{\GMperspectiveX}{signed}{}
 \bsITEM{\GMperspectiveY}{signed}{}
 \bsEND
\end{pseudo}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Wavelet transform}

The $wavelet\_tranform()$ function decodes metadata determining the wavelet 
transform (including filters, wavelet depth, code block structures)
together with the transformed wavelet coefficients.

Decoded wavelet transform coefficient data is stored in the state
variables \YTransform, \UTransform and \VTransform for subsequent 
processing using the inverse wavelet transform (Section \ref{idwt}).

\begin{pseudo}{wavelet\_transform}{state}
\bsIF{is\_intra()}
    \bsCODE{state[\textit{Zero Residual}] = false}
\bsELSE
    \bsCODE{state[\textit{Zero Residual}] = read\_bool()}
\bsEND

\bsIF{ !state[\textit{zero\_residual}]}
    \bsCODE{transform\_parameters(state)}
    \bsCODE{\ComponentWidth = \LumaWidth}
    \bsCODE{\ComponentHeight = \LumaHeight}
    \bsCODE{\YTransform = transform\_data(state)}

    \bsCODE{\ComponentWidth = \ChromaWidth}
    \bsCODE{\ComponentHeight = \ChromaHeight}
    \bsCODE{\UTransform = transform\_data(state)}
    \bsCODE{\VTransform = transform\_data(state)}
\end{pseudo}

Wavelet coefficients have been encoded using arithmetic coding, and their 
decoding is specified in section \ref{transformdec}. The remainder of this
section specifies the decoding of transform parameters.

\begin{pseudo}{transform\_parameters}{state}
\bsCODE{wavelet\_filter()}{\ref{wltfilter}}
\bsCODE{wavelet\_depth()}{\ref{wltdepth}}
\bsCODE{spatial\_partition()}{\ref{spatialpartition}}
\end{pseudo}

\paragraph{Wavelet filters\newline}
\label{wltfilter}
[Say sthg - TBD]
\begin{verbatim}
wavelet_filter():
    unusual_wavelet = read_bool()
    if (unusual_wavelet):
        wavelet_index = read_uint()
\end{verbatim}

\paragraph{Wavelet depth\newline}
\label{wltdepth}
[Say sthg-TBD]

\begin{verbatim}
wavelet_depth():
    unusual_wavelet_depth = read_bool()
    if (unusual_wavelet_depth):
        transform_depth = read_uegol()
\end{verbatim}

\paragraph{Spatial partition of wavelet data\newline}
\label{spatialpartition}

[Say sthg-TBD]

\begin{verbatim}
spatial_partition():
    spatial_partition_flag = read_bool()
    if (spatial_partition_flag):
        custom_partition_flag = read_bool()
        if (custom_partition_flag):
            for level in range(0,transform_depth+1):
                codeblock_size[level] = codeblock_size()
        codeblock_mode_index = read_uegol()
\end{verbatim}
\annotate{df}{should line6 of spatial\_partition be transform\_depth?}

\begin{verbatim}
codeblock_size():
    horizontal_codeblock_size = read_uegol()
    vertical_codeblock_size = read_uegol()
\end{verbatim}
\annotate{df}{i'd flatten codeblock\_size too}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Syntax of block\_data}

The following is for structural reference only, unmarshalling is
described in section X.

inside the blockdata:

\begin{verbatim}
superblock(xpos,ypos):
    superblock_header(xpos,ypos)
    for y in range (0,block_count,step):
        for x in range (0,block_count,step):
            prediction_unit(xpos+x, ypos+x)
\end{verbatim}

\begin{verbatim}
superblock_header():
    split_residual = read_uegola(sb_split_contexts)
    if (split != 0):
        common_residual = read_boola(sb_common_contexts)
\end{verbatim}

\begin{verbatim}
prediction_unit(xpos,ypos):
    if ((xpos%4==0 && ypos%4==0) || (!common)):
        mode = prediction_mode()
    if (mode == [False,False]): # IntraBlock
        dc = DC_value()
    else:
        if (!using_global || !global_only):
            motion_data(xpos,ypos)
\end{verbatim}
\annotate{df}{use DMT to simplify the using global expression. Also,
using\_global may only be true when global\_only is true}

\begin{verbatim}
prediction_mode(xpos,ypos):
    ref1_mode_residual = read_boola(block_mode_ref1_context)
    if (num_of_refs == 2):
        ref2_mode_residual = read_boola(block_mode_ref2_context)
\end{verbatim}

\begin{verbatim}
DC_value(xpos,ypos):
    luma_dc_residual = read_segola(luma_dc_contexts)
    chroma1_dc_residual = read_segola(chroma1_dc_contexts)
    chroma2_dc_residual = read_segola(chroma2_dc_contexts)
\end{verbatim}

\begin{verbatim}
motion_data(xpos,ypos):
    pu_using_global_residual = read_boola(global_block_context)
    if (mode[0] == True && !pu_using_global):
        ref1_vector = motion_vector_ref1(xpos,ypos)
    if (mode[1] == True && !pu_using_global):
        ref2_vector = motion_vector_ref2(xpos,ypos)
\end{verbatim}

\begin{verbatim}
motion_vector_ref1(xpos,ypos):
    horizontal_residual = read_segola(mv_ref1_horiz_contexts)
    vertical_residual = read_segola(mv_ref1_vert_contexts)
\end{verbatim}

\begin{verbatim}
motion_vector_ref2(xpos,ypos):
    horizontal_residual = read_segola(mv_ref2_horiz_contexts)
    vertical_residual = read_segola(mv_ref2_vert_contexts)
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Syntax of compressed subband data}
inside the compressed subband data:

\begin{verbatim}
subband_data():
    if (num_vertical_codeblocks(level) == 1 && num_horizontal_codeblocks(level) == 1):
        for some loop:
            for some loop:
                wavelet_coefficient()
    else:
        multicodeblock stuff, please see section whatever for details.
\end{verbatim}

\begin{verbatim}
codeblock():
    if (codeblock_mode == SingleQuantiser):
        sq_codeblock()
    if (codeblock_mode == MultipleQuantiser):
        mq_codeblock()
\end{verbatim}

\begin{verbatim}
sq_codeblock():
    if (!single_codeblock(level)):
        zero_block_flag = read_boola(zero_codeblock_context)
    TODO
\end{verbatim}

\begin{verbatim}
wavelet_coefficient():
    data[level][band][v][h] = decode_coefficient()
\end{verbatim}

\begin{verbatim}
decode_coefficient():
    read_coeff(contexts)
\end{verbatim}
\annotate{df}{contexts selection is defined in a different section}
