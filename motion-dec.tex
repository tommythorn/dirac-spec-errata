%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how motion data - %
% - is decoded                           - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{motiondec}

This section defines the operation of the $block\_motion\_data()$ process for extracting
block motion data from the Dirac stream. 

Block motion data is aggregated into {\em superblocks}, consisting of a 4x4 array of 
blocks. The number of superblocks horizontally and vertically shall be determined so 
that there are sufficient superblocks to cover the picture area. Superblocks 
may overlap the right and bottom edge of the picture.

\begin{informative}
\\
\begin{enumerate}
\item Since superblocks may overlap the right and bottom edge of the picture, blocks in 
such superblocks may also overlap the edges or even fall outside the picture area
 altogether. Motion data for blocks which fall outside the picture area is still decoded, but
 will not be used for motion compensation (Section \ref{motioncompensate}). 

\item Unlike macroblocks in MPEG standards, a superblock does not encapsulate all 
data within a given area of the picture. It is merely an aggregation device for motion data,
and for this reason a different nomenclature has been adopted.
\end{enumerate}
\end{informative}

\subsection{Prediction modes}

Two types of prediction mode shall be defined: a reference prediction mode, indicating
which references are to be used for motion compensation,  and a global motion
 mode flag, indicating how prediction is to be performed (using global motion or block
 motion for a given block).

Four reference prediction modes shall be defined and shall be denoted by integer
constant values: 
\begin{enumerate}
\item \Intra shall denote value 0, and shall indicate that DC values for a block
shall be decoded and that no motion vectors shall be decoded.
\item  \RefOneOnly shall denote value 1 and shall indicate that a motion vector
for the first reference picture shall be decoded, but no motion vector for the second
reference picture shall be decoded.
\item  \RefTwoOnly shall denote value 2 and shall indicate that a motion vector
for the second reference picture shall be decoded, but no motion vector for the first
reference picture shall be decoded.
\item  \RefOneAndTwo shall denote value 3 and shall indicate that motion vectors
for both the first and second reference picture shall be decoded.
\end{enumerate}

In addition, where global motion is used for a picture (i.e $\PictureUsingGlobal$ is set), 
a global motion mode flag shall be encoded for each block. If $\true$, global motion
compensation shall be used for this block, and no block motion vectors or DC values
shall be encoded. If $\false$, block motion compensation shall be employed and
one or more motion vectors shall be encoded.

\subsection{Splitting modes}

TBC

\subsection{Structure of block motion data arrays}

\label{motionconventions}

For the purposes of this specification, block motion data shall be stored in the 
two dimensional array $\BlockData$. Superblock
splitting modes shall be stored in the two dimensional array $\SBSplit$.

For each block with coordinates $(i,j)$, a block motion data element 
$\BlockData[j][i]$ shall be defined. It is a map (Section \ref{}) and shall
consist of up to five elements:

\begin{enumerate}
\item A motion vector for reference 1, $\BlockData[j][i][\Vect][1]$, consisting of 
integral horizontal and vertical elements $\BlockData[j][i][\Vect][1][0]$ and 
$\BlockData[j][i][\Vect][1][1]$.
\item A motion vector for reference 2, $\BlockData[j][i][\Vect][2]$, consisting of 
integral horizontal and vertical elements $\BlockData[j][i][\Vect][2][0]$ and 
$\BlockData[j][i][\Vect][2][1]$.
\item A set of integral DC values for each component, $\BlockData[j][i][\DC][Y]$,
 $\BlockData[j][i][\DC][C1]$, and $\BlockData[j][i][\DC][C2]$.
\item A reference prediction mode, $\BlockData[j][i][\RMode]$, taking values 0, 1, 2, 
or 3 and indicating which references (if any) are to be used for predicting block $(i,j)$
\item A global motion mode flag, $\BlockData[j][i][\GMode]$
\end{enumerate}

\subsubsection{Block motion data initialisation}

\label{motioninit}

This section specifies the operation of the $initialise\_motion\_data()$ process.
 It shall set the dimensions of the block motion parameter arrays according to the numbers
of blocks and superblocks defined in Section {motiondatadimensions}.

The array $\BlockData$ shall be set to have horizontal dimension $\BlocksX$ and 
vertical dimension $\BlocksY$.

The array $\SBSplit$ shall be set to have horizontal dimension $\SuperblocksX$ 
and vertical dimension $\SuperblocksY$.

\subsection{Motion data decoding process}

This section specifies the overall operation of the $block\_data()$ process for extracting
block motion data elements: motion vectors and block prediction modes. This 
process is called by the $picture\_prediction()$ process (Section \ref{pictureprediction}) and
depends upon the parameters that have been extracted and set in the
$picture\_prediction\_parameters()$ process (Section \ref{picpredparams}).

Block motion data elements are all coded differentially with respect to a spatial prediction. The
spatial prediction processes for the block motion elements are specified in Section \ref{spatialprediction}

\subsubsection{Overall decoding process}

\label{decodingprocess}

The decoding process for the block motion data consists of decoding each of the motion
 data elements in turn. Each motion data element shall consist of an entropy coded block
 preceded by a length code.

\begin{pseudo}{block\_motion\_parameters}{}
\bsCODE{initialise\_motion\_data()}{\ref{motioninit}}
\bsCODE{superblock\_split\_modes()}{\ref{superblocksplit}}
\bsCODE{prediction\_modes()}{\ref{blockpredmodes}}
\bsCODE{vector\_elements(1, 0)}{\ref{blockmvelements}}
\bsCODE{vector\_elements(1, 1)}{\ref{blockmvelements}}
\bsIF{num\_refs()==2}
    \bsCODE{vector\_elements(2,0)}{\ref{blockmvelements}}
    \bsCODE{vector\_elements(2,1)}{\ref{blockmvelements}}
\bsEND
\bsCODE{dc\_values(Y)}{\ref{DCvalues}}
\bsCODE{dc\_values(C1)}{\ref{DCvalues}}
\bsCODE{dc\_values(C2)}{\ref{DCvalues}}
\end{pseudo}

\begin{informative}
The superblock splitting modes determine the number, and location, of 
prediction mode values to be decoded -- there
must be one for each prediction unit within a superblock. Together, the split 
mode and the prediction mode determine the number and location of all other 
motion data elements, which can each be decoded in parallel. Indeed,
by attempting to decode the maximum possible number of prediction residue 
values for all motion data elements, the first 
two motion data elements may also be decoded in parallel with the others. 
Once all residue values are decoded, excess
values can be discarded, the location of values determined and actual 
values reconstructed by prediction. This approach
may be particularly valuable in hardware.

Decoding may proceed in this way, as the arithmetic decoding engine 
allows bits to be read beyond the nominal end of an arithmetically-coded chunk by inserting 1s, hence allowing virtual values to be read.
\end{informative}

\subsubsection{Superblock splitting modes}
\label{superblocksplit}

This section specifies the $superblock\_split\_modes()$ process. It determines the number of prediction units
within each superblock.

\begin{pseudo}{superblock\_split\_modes}{}
\bsITEM{length}{uint}{}
\bsCODE{\ABitsLeft= 8*length}
\bsCODE{byte\_align()}
\bsCODE{ctx\_labels=[\SBSplitFollowOne,\SBSplitFollowTwo,\SBSplitData]}
\bsCODE{initialise\_arithmetic\_decoding(ctx\_labels)}{\ref{initarith}}
\bsFOR{ypos=0}{\SuperblocksY-1}
    \bsFOR{xpos=0}{\SuperblocksX-1}
        \bsCODE{sb\_split\_residual=read\_uinta(sb\_split\_contexts() ) }
        \bsCODE{\SBSplit[ypos][xpos] = sb\_split\_residual}
        \bsCODE{\SBSplit[ypos][xpos]+=split\_prediction(ypos, xpos)}{\ref{splitprediction}}
        \bsCODE{\SBSplit[ypos][xpos] \%= 3}
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\subsubsection{Propagating data between blocks}
\label{propagatedata}

The $propagate\_data(s, r, k,idx)$ copies decoded block data from the top-left-most block
of a set of $k\times k$ blocks. It is used where the splitting mode of a superblock is not 2
 and not all blocks within the superblock will have individually-decoded motion data elements.

\begin{pseudo}{propagate\_data}{s, r, k,label}
\bsFOR{j=s}{s+k-1}
    \bsFOR{i=r}{r+k-1}
        \bsCODE{\BlockData[j][i][label]=\BlockData[s][r][label]}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{Block prediction modes}
\label{blockpredmodes}

The $prediction\_modes()$ process decodes all modes (global motion and block
 prediction) required for each superblock based on
the superblock splitting modes: 16 for split mode 2, 4 for split mode 1, and 1 for 
split mode 0. For split
modes 0 and 1, these are placed in the top-left corner block in each allowed 
prediction unit within the
superblock, and propagated to the other blocks within the prediction unit.

\begin{pseudo}{prediction\_modes}{}
\bsITEM{length}{uint}{}
\bsCODE{\ABitsLeft= 8*length}
\bsCODE{byte\_align()}
\bsCODE{ctx\_labels=[\PredModeOne,\PredModeTwo,\BlockGlobal]}
\bsCODE{initialise\_arithmetic\_decoding(ctx\_labels)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY-1}
    \bsFOR{x=0}{\SuperblocksX-1}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_ref\_mode(4*y+q*step, 4*x+p*step)}{\ref{blockmode}}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,mode)}{\ref{propagatedata}}
                \bsCODE{block\_global\_mode(4*y+q*step, 4*x+p*step)}{\ref{blockglobal}}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,global)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\paragraph{Block prediction mode}
\label{blockmode}

The $block\_ref\_mode(ypos,xpos)$ process parses the block prediction mode for the block at position $(xpos, ypos)$. Each
bit of the block prediction mode is decoded separately.

\begin{pseudo}{block\_ref\_mode}{ypos, xpos}
\bsCODE{\BlockData[ypos][xpos][\RMode] = 0}
\bsIF{read\_boola(\PredModeOne)==\true}
    \bsCODE{\BlockData[ypos][xpos][\RMode] = 1}
\bsEND
\bsIF{num\_refs() == 2}
    \bsIF{read\_boola(\PredModeTwo)==\true}
        \bsCODE{\BlockData[ypos][xpos][\RMode] += 2}
    \bsEND
\bsEND
\bsCODE{\BlockData[ypos][xpos][\RMode] \wedge=ref\_mode\_prediction(ypos, xpos)}{\ref{modeprediction}}
\end{pseudo}


\paragraph{Block global mode}
\label{blockglobal}
$\ $\newline

The $block\_global\_mode(ypos,xpos)$ process parses the global motion mode for the block at position $(xpos, ypos)$. It shall be defined as follows:

\begin{pseudo}{block\_global}{ypos, xpos}
\bsCODE{\BlockData[y][x][\GMode]=\false}
\bsIF{\PictureUsingGlobal==\true}
    \bsIF{\BlockData[ypos][xpos][\RMode]!=\Intra}
        \bsCODE{block\_global\_residue = read\_boola(\BlockGlobal)}
        \bsCODE{\BlockData[ypos][xpos][\GMode] = block\_global\_residue}
        \bsCODE{\BlockData[ypos][xpos][\GMode] \wedge= block\_global\_prediction(ypos, xpos)}{\ref{blockglobalprediction}}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{Block motion vector elements}
\label{blockmvelements}

The $vector\_elements(ref,dirn)$ parses the $dirn$ (horizontal or vertical) component of the motion vectors associated with
reference $ref$.

\begin{pseudo}{vector\_elements}{ref,dirn}
\bsITEM{length}{uint}{}
\bsCODE{\ABitsLeft= 8*length}
\bsCODE{byte\_align()}
\bsCODE{ctx\_labels=\begin{array}{l}[\VectorFollowOne,\VectorFollowTwo,\VectorFollowThree,
\VectorFollowFour,\VectorFollowFivePlus,\\
\VectorData,\VectorSign]
\end{array}}
\bsCODE{initialise\_arithmetic\_decoding(ctx\_labels)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY-1}
    \bsFOR{x=0}{\SuperblocksX-1}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_vector(4*y+q*step, 4*x+p*step,ref,dirn)}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,ref)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

The $block\_vector(ypos, xpos, ref, dirn)$ decodes an individual motion vector element for reference
$ref$ and in direction $dirn$ (0=horizontal, 1=vertical).

\begin{pseudo}{block\_vector}{ypos, xpos, ref, dirn}
\bsIF{\BlockData[ypos][xpos][\RMode][ref] == \true}
    \bsIF{\BlockData[ypos][xpos][\GMode]==\false}
        \bsCODE{mv\_residual = read\_sinta(mv\_contexts() ) }{\ref{mvcontexts}}
        \bsCODE{\BlockData[ypos][xpos][ref][dirn] = mv\_residual}
        \bsCODE{\BlockData[ypos][xpos][ref][dirn] +=mv\_prediction(ypos, xpos, ref, dirn)}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{DC values}
\label{DCvalues}

The $dc\_values(c)$ parses the DC values for component $c$.

\begin{pseudo}{dc\_values}{c}
\bsITEM{length}{uint}{}
\bsCODE{\ABitsLeft= 8*length}
\bsCODE{byte\_align()}
\bsCODE{ctx\_labels=[\DCFollowOne,\DCFollowTwoPlus,\DCData,\DCSign]}
\bsCODE{initialise\_arithmetic\_decoding(ctx\_labels)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY-1}
    \bsFOR{x=0}{\SuperblocksX-1}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_dc(4*y+q*step, 4*x+p*step,ref,dirn)}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,DC)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

The $block\_dc(ypos, xpos,c)$ process parses a block DC value for the block at position 
$(xpos, ypos)$.

\begin{pseudo}{block\_dc}{ypos, xpos,c}
\bsIF{\BlockData[ypos][xpos][\RMode]=\Intra}
    \bsCODE{dc\_residual = read\_sinta(dc\_contexts()) }{\ref{dcvaluecontexts}}
    \bsCODE{\BlockData[ypos][xpos][\DC][c] = dc\_residual}
    \bsCODE{\BlockData[ypos][xpos][\DC][c] +=dc\_prediction(ypos, xpos, c)}{\ref{dcprediction}}
\bsEND
\end{pseudo}

\subsubsection{Spatial prediction of motion data elements}

\label{spatialprediction}

\paragraph{Prediction apertures}

A consistent convention for prediction apertures is used. The nominal prediction 
aperture for block motion data is defined to be the relevant data to the left, top
and top-left of the data element in question (Figure \ref{predaperture}). For the superblock split mode of 
the superblock with index $(i,j)$ this means the superblocks with indices $(i-1,j)$,
$(i,j-1)$ and $(i-1,j-1)$. For the block motion data itself, the same applies where these
indices are {\em block} indices. 

\setlength{\unitlength}{1em}
\begin{figure}[!ht]
\centering
\begin{picture}(15,20)
\multiput(0,0)(8,0){3}%
  {\line(0,1){16}}
\multiput(0,0)(0,8){3}%
  {\line(1,0){16}}
  
%Shading  

\multiput(0,0)0.2,0){40}%  
{\multiput(8,0.1)(0,.2){40}%
  {\tiny.}
}

%Arrows
\put(4,12){\vector(1,-1){6}}
\put(12,12){\vector(0,-1){6}}
\put(4,4){\vector(1,0){6}}
\end{picture}
\caption{Basic prediction aperture}\label{predaperture}
\end{figure}

Note that this is the nominal prediction aperture. Not all data elements in this prediction
aperture may be available, either because they would require negative indices, or because
the data is not available - for example a block to the left of a block with mode \RefTwoOnly
may have mode \RefOneOnly and so can furnish no contribution for a prediction to the
Reference 2 motion vector.

Note also that when superblocks have split level 1 or 0, block data has been propagated
(Section \ref{propagatedata}) across 4 or 16 blocks so as to furnish a prediction. The
effect is illustrated for a variety of splitting modes in Figure \ref{splitapertures}.

\setlength{\unitlength}{.75em}
\begin{figure}[!ht]
\centering
\begin{picture}(60,17.5)

\multiput(0,0)(20,0){3}%
{

%Main Grid
\multiput(0,0)(8,0){3}%
  {\line(0,1){16}}
\multiput(0,0)(0,8){3}%
  {\line(1,0){16}}
\multiput(0,0)0.2,0){40}%  

%Shading
\multiput(0,0)0.4,0){20}% 
{\multiput(8,0.2)(0,.4){20}%
  {\tiny.}
}

%Dotted Grid
\multiput(0,0)(0,2){3}%
{\multiput(0,2)(0.5,0){16}%
   {\line(1,0){.25}}
}
\multiput(0,0)(2,0){3}%
{\multiput(2,0)(0,0.5){16}%
   {\line(0,1){.25}}
}

\multiput(8,0)(0,8){2}%
{\multiput(0,4)(0.5,0){16}%
   {\line(1,0){.25}}
}

\multiput(12,0)(0,0.5){32}%
   {\line(0,1){.25}}
}
%Arrows
\put(4,12){\vector(1,-1){5}}
\put(7,7) {\vector(2,-1){1.5}}
\put(10,10){\vector(0,-1){3}}

\put(30,6){\vector(0,-1){3.5}}
\put(27,5) {\vector(1,-1){2}}
\put(27,3){\vector(2,-1){2}}

\put(50,2){\vector(1,0){3.5}}
\put(50,6) {\vector(1,-1){3.5}}
\put(54,6){\vector(0,-1){3.5}}

\end{picture}
\caption{Effect of splitting modes on spatial prediction}\label{splitapertures}
\end{figure}

\paragraph{Superblock split prediction}
\label{splitprediction}
$\ $\newline
$split\_prediction$ returns the mean of the the neighbouring split values:

\begin{pseudo}{split\_prediction}{ypos, xpos}
\bsIF{ xpos==0 \text{\bf and } ypos==0 }
    \bsRET{0}
\bsELSEIF{ypos==0}
    \bsRET{\SBSplit[ypos][xpos-1]}
\bsELSEIF{xpos==0}
    \bsRET{\SBSplit[ypos-1][xpos]}
\bsEND

\bsCODE{ 
\begin{array}{ll}
\text{return} & \mean(\SBSplit[ypos-1][xpos-1], \\
                   &  \quad\quad\quad \SBSplit[ypos][xpos-1],  \\
                   &  \quad\quad\quad \SBSplit[ypos-1][xpos])
\end{array}
}
\end{pseudo}

\paragraph{Block mode prediction}
\label{modeprediction}
$\ $\newline
The $ref\_mode\_prediction()$ function shall return a value that represents a majority
 verdict for the presence of each of the references individually. It shall be defined
 as follows:

\begin{pseudo}{ref\_mode\_prediction}{ypos, xpos}
\bsIF{ xpos==0 \text{\bf and } ypos==0 }
    \bsRET{\Intra}
\bsELSEIF{ypos==0}
    \bsRET{\BlockData[0][xpos-1][\RMode]}
\bsELSEIF{xpos==0}
    \bsRET{\BlockData[ypos-1][0][\RMode]}
\bsELSE
    \bsCODE{num\_ref1\_nbrs=\BlockData[ypos-1][xpos] \& 1}
    \bsCODE{num\_ref1\_nbrs +=\BlockData[ypos-1][xpos-1] \& 1}
    \bsCODE{num\_ref1\_nbrs +=\BlockData[ypos][xpos-1] \& 1}
    \bsCODE{pred=num\_ref1\_nbrs//2}    
    \bsCODE{num\_ref2\_nbrs=(\BlockData[ypos-1][xpos]\gg 1) \& 1}
    \bsCODE{num\_ref2\_nbrs +=(\BlockData[ypos-1][xpos-1] \gg 1) \& 1}
    \bsCODE{num\_ref2\_nbrs +=(\BlockData[ypos][xpos-1] \gg 1) \& 1}
    \bsCODE{pred \wedge= (num\_ref2\_nbrs//2)\ll 1}    
    \bsRET{pred}
\bsEND
\end{pseudo}

\paragraph{Block global flag prediction}
\label{blockglobalprediction}
$\ $\newline

$block\_global\_prediction$ returns a majority verdict of the neighbouring blocks:

\begin{pseudo}{block\_global\_prediction}{ypos, xpos}
\bsIF{ xpos==0 \text{\bf and } ypos==0 }
    \bsRET{\false}
\bsELSEIF{ ypos==0 }
    \bsRET{\BlockData[ypos][xpos-1][\GMode]}
\bsELSEIF{xpos==0}
    \bsRET{\BlockData[ypos-1][xpos][\GMode]}
\bsEND

\bsCODE{
\begin{array}{ll}
\text{return} & \majority(\BlockData[ypos-1][xpos-1][\GMode], \\
& \quad\quad\quad \BlockData[ypos-1][xpos][\GMode],  \\
& \quad\quad\quad \BlockData[ypos][xpos-1][\GMode]) 
\end{array}
}

\end{pseudo}

\paragraph{Motion vector prediction}
\label{mvprediction}
$\ $\newline
Motion vectors are predicted using the median of available block vectors in the aperture. A vector is available for
prediction if a) its block falls within the picture area and b) its prediction mode allows it to be defined and c) it
is not a global motion block. 

The process $mv\_prediction(ypos, xpos, ref, dirn)$ returns motion values according to
the following rules:

{\bf Case 1.}  If $xpos==0$ and $ypos==0$, there are no vectors in the prediction aperture and
 $0$ is returned.

{\bf Case 2.} If $xpos>0$ and $ypos==0$ then:
\begin{enumerate}
   \item If 

$\BlockData[ypos][xpos-1][\GMode]==\false$ 

and 

$\BlockData[ypos][xpos-1][\RMode][ref]==\true$ 

then vector element $\BlockData[ypos][xpos-1][ref][dirn]$ is returned.

   \item Otherwise, $0$ is returned
\end{enumerate}

{\bf Case 3.} If $xpos==0$ and $ypos>0$ then:
\begin{enumerate}
   \item If 

$\BlockData[ypos-1][xpos][\GMode]==\false$ 

and 

$\BlockData[ypos-1][xpos][\RMode][ref]==\true$

then vector element $\BlockData[ypos-1][xpos][ref][dirn]$ is returned.

   \item Otherwise, $0$ is returned
\end{enumerate}

{\bf Case 4.} If both $xpos>0$ and $ypos>0$ then all 3 blocks in the prediction aperture may potentially
contribute to the prediction. Define the set $values=\emptyset$. The prediction is the 
median of the available vector elements:

\begin{pseudo*}
\bsIF{xpos>0 \text{ and } ypos>0 }
    \bsIF{\BlockData[ypos][xpos-1][\GMode]==\false}
        \bsIF{\BlockData[ypos][xpos-1][\RMode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos][xpos-1][ref][dirn] \} }
        \bsEND
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos][\GMode]==\false}
        \bsIF{\BlockData[ypos-1][xpos][\RMode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos][ref][dirn] \} }
        \bsEND
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos-1][\GMode]==\false}
        \bsIF{\BlockData[ypos-1][xpos-1][\RMode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos-1][ref][dirn] \} }
        \bsEND
    \bsEND

    \bsRET{\median(values)}
\bsEND
\end{pseudo*}

(Note that the median of an empty set is zero.)

\paragraph{DC value prediction}
\label{dcprediction}
$\ $\newline
DC values are predicted using the unbiased mean available values in the aperture. The
process $dc\_prediction(ypos, xpos, comp)$ returns values according to
the following rules:

{\bf Case 1.}  If $xpos==0$ and $ypos==0$, there are no blocks in the prediction aperture and
the default prediction 0 is returned.

{\bf Case 2.} If $xpos>0$ and $ypos==0$ then:
\begin{enumerate}
   \item If $\BlockData[ypos][xpos-1][\RMode]==\Intra$, $\BlockData[ypos][xpos-1][\DC][comp]$ is returned
   \item Otherwise, 0 is returned
\end{enumerate}

{\bf Case 3.} If $xpos==0$ and $ypos>0$ then:
\begin{enumerate}
   \item If $\BlockData[ypos-1][xpos][\RMode]==\Intra$, $\BlockData[ypos-1][xpos][\DC][comp$ is returned
   \item Otherwise, 0 is returned
\end{enumerate}

{\bf Case 4.} If both $xpos>0$ and $ypos>0$ then all 3 blocks in the prediction aperture may potentially
contribute to the prediction. Define a set $values=\emptyset$. The prediction is the 
unbiased mean of available values:

\begin{pseudo*}
\bsIF{ xpos>0 \text{ and } ypos>0 }
    \bsIF{\BlockData[ypos][xpos-1][\RMode]==\Intra}
        \bsCODE{values = values\cup\{\BlockData[ypos][xpos-1][\DC][comp] \} }
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos][\RMode]==\Intra}
        \bsCODE{values = valuesx\cup\{\BlockData[ypos-1][xpos][ref][\DC][comp] \} }
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos-1][\RMode]==\Intra}
        \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos-1][ref][\DC][comp] \} }
    \bsEND

    \bsIF{values!=\emptyset}
        \bsRET{pred =\mean(values)}
    \bsELSE
        \bsRET{0}
    \bsEND
\bsEND
\end{pseudo*}


\subsubsection{Block motion parameter contexts}

\paragraph{Superblock splitting mode}
$\ $\newline
The $sb\_split\_contexts()$ function returns the following unsigned integer context set:

\begin{itemize}
\item Follow = [ \SBSplitFollowOne, \SBSplitFollowTwo ]
\item Data = \SBSplitData
\end{itemize}

\paragraph{Motion vectors}
\label{mvcontexts}
$\ $\newline
There is a single signed integer context set for motion vector data, which is re-used for each of the four vector elements
(references 1 and 2, horizontal and vertical).

$mv\_contexts()$ returns the set with
\begin{itemize}
\item Follow = [ \VectorFollowOne, \VectorFollowTwo, \VectorFollowThree, \VectorFollowFour, \VectorFollowFivePlus ]
\item Data = \VectorData
\item Sign = \VectorSign
\end{itemize}

\paragraph{DC values}
\label{dcvaluecontexts}

There is a single signed integer context set for DC values, which is reused for each component. 

$dc\_contexts(Y)$ returns the set:

\begin{itemize}
\item Follow = [ \DCFollowOne, \DCFollowTwoPlus ]
\item Data = \DCData
\item Sign = \DCSign
\end{itemize}

