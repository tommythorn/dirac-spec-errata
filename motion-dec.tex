%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how motion data - %
% - is decoded                           - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{motiondec}

This section specifies the operation of the $block\_data()$ process for extracting
block motion data from the Dirac stream. 

Block data is aggregated into {\em superblocks}, consisting of a 4x4 array of blocks. The number 
of superblocks horizontally and vertically is determined so that there are sufficient superblocks
to cover the picture area. Superblocks may overlap the right and bottom edge of the picture.

\begin{informative}
Since superblocks may overlap the right and bottom edge of the picture, blocks in such superblocks
may also overlap the edges or even fall outside the picture area altogether. Motion data for 
blocks which fall outside the picture area is still decoded, but will not be used for motion compensation 
(Section \ref{motioncompensate}). 

Unlike macroblocks in MPEG standards, a superblock does not encapsulate all data within a 
given area of the picture. It is merely an aggregation device for motion data, and for this reason
a different nomenclature has been adopted.
\end{informative}

\subsection{Motion data conventions}

\label{motionconventions}

For the purposes of this specification, block motion data is stored in a two dimensional array 
$\BlockData$ of block data structures. A block motion data element ${\bf b}=\BlockData[j][i]$ consists of:

\begin{itemize}
\item A motion vector for reference 1, ${\bf b}[ref1]$, with integral horizontal element ${\bf b}[ref1][0]$ and 
vertical element ${\bf b}[ref1][1]$
\item A motion vector for reference 2, ${\bf b}[ref2]$, with integral horizontal element ${\bf b}[ref2][0]$ and 
vertical element ${\bf b}[ref2][1]$
\item A set of integral DC values, ${\bf b}[dc][Y]$, ${\bf b}[dc][C1]$, and ${\bf b}[dc][C2]$ for each component
\item A prediction mode, ${\bf b}[mode]$, consisting of two flags ${\bf b}[mode][1]$ and ${\bf b}[mode][2]$ 
indicating whether the corresponding reference is to be used for predicting block $(i,j)$
\item A global motion flag, ${\bf b}[global]$, which is set to $\true$ if global motion prediction is to be used for
that block
\end{itemize}

Four block prediction modes shall be supported by the decoder: 

\begin{itemize}
\item \Intra - corresponding to ${\bf b}[mode][1]=\false$ and ${\bf b}[mode][2]=\false$, and using DC prediction only
\item \RefOneOnly - corresponding to ${\bf b}[mode][1]=\true$ and ${\bf b}[mode][2]=\false$, and using a prediction from Reference 1 only
\item \RefTwoOnly - corresponding to ${\bf b}[mode][1]=\false$ and ${\bf b}[mode][2]=\true$, and using a prediction from Reference 2 only
\item \RefOneAndTwo - corresponding to ${\bf b}[mode][1]=\true$ and ${\bf b}[mode][2]=\true$, and using a prediction from Reference 1 and Reference 2
\end{itemize}

In this way, Reference $X$ is used for prediction if and only if ${\bf b}[mode][X]=\true$. 

\subsection{Motion data decoding process}

This section specifies the overall operation of the $block\_data()$ process for extracting
block motion data elements: motion vectors and block prediction modes. This 
process is called by the $picture\_prediction()$ process (Section \ref{pictureprediction}) and
depends upon the parameters that have been extracted and set in the
$picture\_prediction\_parameters()$ process (Section \ref{picpredparams}).

Block motion data elements are all coded differentially with respect to a spatial prediction. The
spatial prediction processes for the block motion elements are specified in Section \ref{spatialprediction}

\subsubsection{Overall decoding process}

\label{decodingprocess}

The decoding process for the block motion data consists of decoding each of the motion data elements in turn. Each
motion data element is consists of an entropy coded block preceded by a length code.

\begin{pseudo}{block\_data}{}
\bsCODE{initialise\_motion\_data()}{\ref{motioninit}}
\bsCODE{superblock\_split\_modes()}{\ref{superblocksplit}}
\bsCODE{prediction\_modes()}{\ref{blockpredmodes}}
\bsCODE{vector\_elements(1, 0)}{\ref{blockmvelements}}
\bsCODE{vector\_elements(1, 1)}{\ref{blockmvelements}}
\bsIF{\NumRefs==2}
    \bsCODE{vector\_elements(2,0)}{\ref{blockmvelements}}
    \bsCODE{vector\_elements(2,1)}{\ref{blockmvelements}}
\bsEND
\bsCODE{dc\_values(Y)}{\ref{DCvalues}}
\bsCODE{dc\_values(C1)}{\ref{DCvalues}}
\bsCODE{dc\_values(C2)}{\ref{DCvalues}}
\end{pseudo}

\begin{informative}
The superblock splitting modes determine the number, and location, of prediction mode values to be decoded -- there
must be one for each prediction unit within a superblock. Together, the split mode and the prediction mode
determine the number and location of all other motion data elements, which can each be decoded in parallel. Indeed,
by attempting to decode the maximum possible number of prediction residue values for all motion data elements, the first 
two motion data elements may also be decoded in parallel with the others. Once all residue values are decoded, excess
values can be discarded, the location of values determined and actual values reconstructed by prediction. This approach
may be particularly valuable in hardware.

Decoding may proceed in this way, as the arithmetic decoding engine allows bits to be read beyond the nominal
end of an arithmetically-coded chunk by inserting 1s, hence allowing virtual values to be read.
\end{informative}

\subsubsection{Motion data initialisation}

\label{motioninit}

This section specifies the operation of the $initialise\_motion\_data()$ process. It sets the dimension variables determining the
number of blocks and superblocks and hence the dimension of the $\BlockData$ array encapsulating block motion
data.

The number of superblocks horizontally and vertically is set by:

\begin{eqnarray*}
\SuperblocksX & = & \left\lceil \frac{\LumaWidth}{4*\LumaXBsep} \right\rceil  \\
\SuperblocksY & = & \left\lceil \frac{\LumaHeight}{4*\LumaYBsep} \right\rceil 
\end{eqnarray*}

The number of blocks horizontally and vertically is set by:

\begin{eqnarray*}
\BlocksX = 4*\SuperblocksX \\
\BlocksY = 4*\SuperblocksY
\end{eqnarray*}

The array $\BlockData$ is set to have horizontal dimension $\BlocksX$ and vertical dimension $\BlocksY$.

The array $\SBSplit$ is set to have horizontal dimension $\SuperblocksX$ and vertical dimension $\SuperblocksY$.

\subsubsection{Superblock splitting modes}
\label{superblocksplit}

This section specifies the $superblock\_split\_modes()$ process. It determines the number of prediction units
within each superblock.

\begin{pseudo}{superblock\_split\_modes}{}
\bsITEM{length}{uint}{}
\bsCODE{byte\_align()}
\bsCODE{initialise\_arithmetic\_decoding(length)}{\ref{initarith}}
\bsFOR{ypos=0}{\SuperblocksY}
    \bsFOR{xpos=0}{\SuperblocksX}
        \bsCODE{sb\_split\_residual=read\_uinta(sb\_split\_contexts() ) }
        \bsCODE{\SBSplit[ypos][xpos] = sp\_split\_residual}
        \bsCODE{\SBSplit[ypos][xpos]+=split\_prediction(ypos, xpos)}{\ref{splitprediction}}
        \bsCODE{\SBSplit[ypos][xpos] \%= 3}
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\subsubsection{Propagating data between blocks}
\label{propagatedata}

The $propagate\_data(s, r, k,idx)$ copies decoded block data from the top-left-most block
of a set of $k\times k$ blocks. It is used where the splitting mode of a superblock is not 2 and not all
blocks within the superblock will have individually-decoded motion data elements.

\begin{pseudo}{propagate\_data}{s, r, k,idx}
\bsFOR{j=s}{s+k-1}
    \bsFOR{i=r}{r+k-1}
        \bsCODE{\BlockData[j][i][idx]=\BlockData[s][r][idx]}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{Block prediction modes}
\label{blockpredmodes}

The $prediction\_modes()$ process decodes all modes (global motion and block prediction) 
required for each superblock based on
the superblock splitting modes: 16 for split mode 2, 4 for split mode 1, and 1 for split mode 0. For split
modes 0 and 1, these are placed in the top-left corner block in each allowed prediction unit within the
superblock, and propagated to the other blocks within the prediction unit.

\begin{pseudo}{prediction\_modes}{}
\bsITEM{length}{uint}{}
\bsCODE{byte\_align()}
\bsCODE{initialise\_arithmetic\_decoding(length)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY}
    \bsFOR{x=0}{\SuperblocksX}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_mode(4*y+q*step, 4*x+p*step)}{\ref{blockmode}}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,mode)}{\ref{propagatedata}}
                \bsCODE{block\_global(4*y+q*step, 4*x+p*step)}{\ref{blockmode}}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,global)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\paragraph{Block prediction mode}
\label{blockmode}

The $block\_mode(ypos,xpos)$ process parses the block prediction mode for the block at position $(xpos, ypos)$. Each
bit of the block prediction mode is decoded separately.

\begin{pseudo}{block\_mode}{ypos, xpos}
\bsCODE{pred\_mode\_residue = read\_boola(\PredModeOne)}
\bsCODE{\BlockData[ypos][xpos][mode][1] =pred\_mode\_residue}
\bsCODE{\BlockData[ypos][xpos][mode][1] \wedge=mode\_prediction(ypos, xpos, 1)}{\ref{modeprediction}}
\bsIF{\NumRefs == 2}
    \bsCODE{pred\_mode\_residue = read\_boola(\PredModeTwo)}
    \bsCODE{\BlockData[ypos][xpos][mode][2] =pred\_mode\_residue}
    \bsCODE{\BlockData[ypos][xpos][mode][2]\wedge= mode\_prediction(ypos, xpos, 2)} {\ref{modeprediction}}
\bsEND
\end{pseudo}

\paragraph{Block global mode\\}
\label{blockglobal}

The $block\_mode(ypos,xpos)$ process parses the global motion mode for the block at position $(xpos, ypos)$.

\begin{pseudo}{block\_global}{ypos, xpos}
\bsCODE{\BlockData[y][x][global]=\false}
\bsIF{\PictureUsingGlobal==\true}
    \bsIF{\BlockData[ypos][xpos][mode]!=\Intra}
        \bsCODE{block\_global\_residue = read\_boola(\BlockGlobal)}
        \bsCODE{\BlockData[ypos][xpos][global] = block\_global\_residue}
        \bsCODE{\BlockData[ypos][xpos][global] \wedge= block\_global\_prediction(ypos, xpos)}{\ref{blockglobalprediction}}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{Block motion vector elements}
\label{blockmvelements}

The $vector\_elements(ref,dirn)$ parses the $dirn$ (horizontal or vertical) component of the motion vectors associated with
reference $ref$.

\begin{pseudo}{vector\_elements}{ref,dirn}
\bsITEM{length}{uint}{}
\bsCODE{byte\_align()}
\bsCODE{initialise\_arithmetic\_decoding(length)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY}
    \bsFOR{x=0}{\SuperblocksX}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_vector(4*y+q*step, 4*x+p*step,ref,dirn)}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,ref)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

The $block\_vector(ypos, xpos, ref, dirn)$ decodes an individual motion vector element for reference
$ref$ and in direction $dirn$ (0=horizontal, 1=vertical).

\begin{pseudo}{block\_vector}{ypos, xpos, ref, dirn}
\bsIF{\BlockData[ypos][xpos][mode][ref] == \true}
    \bsIF{\BlockData[ypos][xpos][global]==\false}
        \bsCODE{mv\_residual = read\_sinta(mv\_contexts() ) }{\ref{mvcontexts}}
        \bsCODE{\BlockData[ypos][xpos][ref][dirn] = mv\_residual}
        \bsCODE{\BlockData[ypos][xpos][ref][dirn] +=mv\_prediction(ypos, xpos, ref, dirn)}
    \bsEND
\bsEND
\end{pseudo}

\subsubsection{DC values}
\label{DCvalues}

The $dc\_values(c)$ parses the DC values for component $c$.

\begin{pseudo}{dc\_values}{c}
\bsITEM{length}{uint}{}
\bsCODE{byte\_align()}
\bsCODE{initialise\_arithmetic\_decoding(length)}{\ref{initarith}}
\bsFOR{y=0}{\SuperblocksY}
    \bsFOR{x=0}{\SuperblocksX}
        \bsCODE{block\_count = 2^{\SBSplit[y][x]}}
        \bsCODE{step = 4//block\_count }
        \bsFOR{q=0}{block\_count-1}
            \bsFOR{p=0}{block\_count-1}
                \bsCODE{block\_dc(4*y+q*step, 4*x+p*step,ref,dirn)}
                \bsCODE{propagate\_data(4*y+q*step, 4*x+p*step, step,DC)}{\ref{propagatedata}}
           \bsEND
        \bsEND
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

The $block\_dc(ypos, xpos,c)$ process parses a block DC value for the block at position 
$(xpos, ypos)$.

\begin{pseudo}{block\_dc}{ypos, xpos,c}
\bsIF{\BlockData[ypos][xpos][mode]=\Intra}
    \bsCODE{dc\_residual = read\_sinta(dc\_contexts()) }{\ref{dcvaluecontexts}}
    \bsCODE{\BlockData[ypos][xpos][dc][c] = dc\_residual}
    \bsCODE{\BlockData[ypos][xpos][dc][c] +=dc\_prediction(ypos, xpos, c)}{\ref{dcprediction}}
\bsEND
\end{pseudo}

\subsubsection{Spatial prediction of motion data elements}

\label{spatialprediction}

\paragraph{Prediction apertures}

A consistent convention for prediction apertures is used. The nominal prediction 
aperture for block motion data is defined to be the relevant data to the left, top
and top-left of the data element in question (Figure \ref{predaperture}). For the superblock split mode of 
the superblock with index $(i,j)$ this means the superblocks with indices $(i-1,j)$,
$(i,j-1)$ and $(i-1,j-1)$. For the block motion data itself, the same applies where these
indices are {\em block} indices. 

\setlength{\unitlength}{1em}
\begin{figure}[!ht]
\centering
\begin{picture}(15,20)
\multiput(0,0)(8,0){3}%
  {\line(0,1){16}}
\multiput(0,0)(0,8){3}%
  {\line(1,0){16}}
  
%Shading  

\multiput(0,0)0.2,0){40}%  
{\multiput(8,0.1)(0,.2){40}%
  {\tiny.}
}

%Arrows
\put(4,12){\vector(1,-1){6}}
\put(12,12){\vector(0,-1){6}}
\put(4,4){\vector(1,0){6}}
\end{picture}
\caption{Basic prediction aperture}\label{predaperture}
\end{figure}

Note that this is the nominal prediction aperture. Not all data elements in this prediction
aperture may be available, either because they would require negative indices, or because
the data is not available - for example a block to the left of a block with mode \RefTwoOnly
may have mode \RefOneOnly and so can furnish no contribution for a prediction to the
Reference 2 motion vector.

Note also that when superblocks have split level 1 or 0, block data has been propagated
(Section \ref{propagatedata}) across 4 or 16 blocks so as to furnish a prediction. The
effect is illustrated for a variety of splitting modes in Figure \ref{splitapertures}.

\setlength{\unitlength}{.75em}
\begin{figure}[!ht]
\centering
\begin{picture}(60,17.5)

\multiput(0,0)(20,0){3}%
{

%Main Grid
\multiput(0,0)(8,0){3}%
  {\line(0,1){16}}
\multiput(0,0)(0,8){3}%
  {\line(1,0){16}}
\multiput(0,0)0.2,0){40}%  

%Shading
\multiput(0,0)0.4,0){20}% 
{\multiput(8,0.2)(0,.4){20}%
  {\tiny.}
}

%Dotted Grid
\multiput(0,0)(0,2){3}%
{\multiput(0,2)(0.5,0){16}%
   {\line(1,0){.25}}
}
\multiput(0,0)(2,0){3}%
{\multiput(2,0)(0,0.5){16}%
   {\line(0,1){.25}}
}

\multiput(8,0)(0,8){2}%
{\multiput(0,4)(0.5,0){16}%
   {\line(1,0){.25}}
}

\multiput(12,0)(0,0.5){32}%
   {\line(0,1){.25}}
}
%Arrows
\put(4,12){\vector(1,-1){5}}
\put(7,7) {\vector(2,-1){1.5}}
\put(10,10){\vector(0,-1){3}}

\put(30,6){\vector(0,-1){3.5}}
\put(27,5) {\vector(1,-1){2}}
\put(27,3){\vector(2,-1){2}}

\put(50,2){\vector(1,0){3.5}}
\put(50,6) {\vector(1,-1){3.5}}
\put(54,6){\vector(0,-1){3.5}}

\end{picture}
\caption{Effect of splitting modes on spatial prediction}\label{splitapertures}
\end{figure}

\paragraph{Superblock split prediction \\}
\label{splitprediction}

$split\_prediction$ returns the mean of the the neighbouring split values:

\begin{pseudo}{split\_prediction}{ypos, xpos}
\bsIF{ xpos==0 \&\& ypos==0 }
    \bsRET{0}
\bsELSEIF{ypos==0}
    \bsRET{\SBSplit[ypos][xpos-1]}
\bsELSEIF{xpos==0}
    \bsRET{\SBSplit[ypos-1][xpos]}
\bsEND

\bsCODE{ 
\begin{array}{ll}
\text{return} & \mean(\SBSplit[ypos-1][xpos-1], \\
                   &  \quad\quad\quad \SBSplit[ypos][xpos-1],  \\
                   &  \quad\quad\quad \SBSplit[ypos-1][xpos])
\end{array}
}
\end{pseudo}

\paragraph{Block mode prediction \\}
\label{modeprediction}

$mode\_prediction$ returns a majority verdict for each of the references:

\begin{pseudo}{mode\_prediction}{ypos, xpos, n}
\bsIF{ xpos==0 \&\& ypos==0 }
    \bsRET{\false}
\bsELSEIF{ypos==0}
    \bsRET{\BlockData[ypos][xpos-1][mode][n]}
\bsELSEIF{xpos==0}
    \bsRET{\BlockData[ypos-1][xpos][mode][n]}
\bsEND
\bsCODE{
\begin{array}{ll}
\text{return} & \majority(\BlockData[ypos-1][xpos-1][mode][n], \\
& \quad\quad\quad \BlockData[ypos-1][xpos][mode][n], \\
& \quad\quad\quad \BlockData[ypos][xpos-1][mode][n] )
\end{array}
}

\end{pseudo}

\paragraph{Block global flag prediction \\}
\label{blockglobalprediction}

$block\_global\_prediction$ returns a majority verdict of the neighbouring blocks:

\begin{pseudo}{block\_global\_prediction}{ypos, xpos}
\bsIF{ xpos==0 \&\& ypos==0 }
    \bsRET{\false}
\bsELSEIF{ ypos==0 }
    \bsRET{\BlockData[ypos][xpos-1][global]}
\bsELSEIF{xpos==0}
    \bsRET{\BlockData[ypos-1][xpos][global]}
\bsEND

\bsCODE{
\begin{array}{ll}
\text{return} & \majority(\BlockData[ypos-1][xpos-1][global], \\
& \quad\quad\quad \BlockData[ypos-1][xpos][global],  \\
& \quad\quad\quad \BlockData[ypos][xpos-1][global]) 
\end{array}
}

\end{pseudo}

\paragraph{Motion vector prediction \\}
\label{mvprediction}

Motion vectors are predicted using the median of available block vectors in the aperture. A vector is available for
prediction if a) its block falls within the picture area and b) its prediction mode allows it to be defined and c) it
is not a global motion block. 

The process $mv\_prediction(ypos, xpos, ref, dirn)$ returns motion values according to
the following rules:

{\bf Case 1.}  If $xpos==0$ and $ypos==0$, there are no vectors in the prediction aperture and
 $0$ is returned.

{\bf Case 2.} If $xpos>0$ and $ypos==0$ then:
\begin{enumerate}
   \item If 

$\BlockData[ypos][xpos-1][global]==\false$ 

and 

$\BlockData[ypos][xpos-1][mode][ref]==\true$ 

then vector element $\BlockData[ypos][xpos-1][ref][dirn]$ is returned.

   \item Otherwise, $0$ is returned
\end{enumerate}

{\bf Case 3.} If $xpos==0$ and $ypos>0$ then:
\begin{enumerate}
   \item If 

$\BlockData[ypos-1][xpos][global]==\false$ 

and 

$\BlockData[ypos-1][xpos][mode][ref]==\true$

then vector element $\BlockData[ypos-1][xpos][ref][dirn]$ is returned.

   \item Otherwise, $0$ is returned
\end{enumerate}

{\bf Case 4.} If both $xpos>0$ and $ypos>0$ then all 3 blocks in the prediction aperture may potentially
contribute to the prediction. Define the set $values=\emptyset$. The prediction is the 
median of the available vector elements:

\begin{pseudo*}
\bsIF{xpos>0 \text{ and } ypos>0 }
    \bsIF{\BlockData[ypos][xpos-1][global]==\false}
        \bsIF{\BlockData[ypos][xpos-1][mode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos][xpos-1][ref][dirn] \} }
        \bsEND
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos][global]==\false}
        \bsIF{\BlockData[ypos-1][xpos][mode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos][ref][dirn] \} }
        \bsEND
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos-1][global]==\false}
        \bsIF{\BlockData[ypos-1][xpos-1][mode][ref]==\true}
            \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos-1][ref][dirn] \} }
        \bsEND
    \bsEND

    \bsRET{\median(values)}
\bsEND
\end{pseudo*}

(Note that the median of an empty set is zero.)

\paragraph{DC value prediction \\}
\label{dcprediction}

DC values are predicted using the unbiased mean available values in the aperture. The
process $dc\_prediction(ypos, xpos, comp)$ returns values according to
the following rules:

{\bf Case 1.}  If $xpos==0$ and $ypos==0$, there are no blocks in the prediction aperture and
the default prediction $2^{\VideoDepth-1}$ is returned.

{\bf Case 2.} If $xpos>0$ and $ypos==0$ then:
\begin{enumerate}
   \item If $\BlockData[ypos][xpos-1][mode]==\Intra$, $\BlockData[ypos][xpos-1][dc][comp]$ is returned
   \item Otherwise, $2^{\VideoDepth-1}$ is returned
\end{enumerate}

{\bf Case 3.} If $xpos==0$ and $ypos>0$ then:
\begin{enumerate}
   \item If $\BlockData[ypos-1][xpos][mode]==\Intra$, $\BlockData[ypos-1][xpos][dc][comp$ is returned
   \item Otherwise, $2^{\VideoDepth-1}$ is returned
\end{enumerate}

{\bf Case 4.} If both $xpos>0$ and $ypos>0$ then all 3 blocks in the prediction aperture may potentially
contribute to the prediction. Define a set $values=\emptyset$. The prediction is the 
unbiased mean of available values:

\begin{pseudo*}
\bsIF{ xpos>0 \text{ and } ypos>0 }
    \bsCODE{pred=(0, 0)}
    \bsIF{\BlockData[ypos][xpos-1][mode]==\Intra}
        \bsCODE{values = values\cup\{\BlockData[ypos][xpos-1][dc][comp] \} }
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos][mode]==\Intra}
        \bsCODE{values = valuesx\cup\{\BlockData[ypos-1][xpos][ref][dc][comp] \} }
    \bsEND
    \bsIF{\BlockData[ypos-1][xpos-1][mode]==\Intra}
        \bsCODE{values = values\cup\{\BlockData[ypos-1][xpos-1][ref][dc][comp] \} }
    \bsEND

    \bsIF{values!=\emptyset}
        \bsRET{pred =\mean(values)}
    \bsELSE
        \bsRET{2^{\VideoDepth-1}}
    \bsEND
\bsEND
\end{pseudo*}


\subsubsection{Block motion data contexts}

\paragraph{Superblock splitting mode\\}

The $sb\_split\_contexts()$ function returns the following unsigned integer context set:

\begin{itemize}
\item Follow = [ \SBSplitFollowOne, \SBSplitFollowTwo ]
\item Data = \SBSplitData
\end{itemize}

\paragraph{Motion vectors\\}
\label{mvcontexts}

There is a single signed integer context set for motion vector data, which is re-used for each of the four vector elements
(references 1 and 1, horizontal and vertical).

$mv\_contexts()$ returns the set with
\begin{itemize}
\item Follow = [ \VectorFollowOne, \VectorFollowTwo, \VectorFollowThree, \VectorFollowFour, \VectorFollowFivePlus ]
\item Data = \VectorData
\item Sign = \VectorSign
\end{itemize}

\paragraph{DC values \\}
\label{dcvaluecontexts}

There is a single signed integer context set for DC values, which is reused for each component. 

$dc\_contexts(Y)$ returns the set:

\begin{itemize}
\item Follow = [ \DCFollowOne, \DCFollowTwoPlus ]
\item Data = \DCData
\item Sign = \DCSign
\end{itemize}

