%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines the arithmetic decoding  - %
% - engine                                        - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{arithdecoding}

This section describes the arithmetic decoding engine and
processes for using it to extract data from the Dirac stream.

The arithmetic decoding engine consists of two elements: 

\begin{itemize}
\item a collection of state variables representing the state of the arithmetic 
decoder (Section \ref{initarith})
\item a set of functions for extracting values from the decoder 
and updating the decoder state (Section \ref{extractarith})
\end{itemize}

\subsection{State and contexts}
\label{arithcontexts}

The arithmetic decoder state consists of the following decoder state variables:

\begin{itemize}
\item $\ALow$, an integer representing the beginning of the current coding interval
\item $\ARange$, an integer representing the size of the current coding interval
\item $\ACode$, an integer within the interval from $\ALow$ to $\AHigh$, determined from the encoded bitstream
\item $\ABitsLeft$, a decrementing count of the number of bits yet to be read in
\item $\AContexts$, a map of all the contexts used in the Dirac decoder
\end{itemize}

A context $context$ is an integer array consisting of three positive values:
\begin{itemize}
\item $context[count0]$ is a count of the number of zeroes
\item $context[count1]$ is a count of the number of ones
\item $context[prob0]$ is an estimate of the probability of zero to 16 bit accuracy
\end{itemize}

Contexts are accessed by decoding functions
via the indices defined in Section \ref{contextindices}. 

Although counts are updated with each symbol decoded, the probability is only updated occasionally, as it is computationally
expensive (see Section \ref{rescalecontext} below).

\subsubsection{Rescaling contexts and probabilities}
\label{rescalecontext}

Contexts maintain counts to 8 bit accuracy, and contexts are rescaled when the total count (count0+count1) reaches 256. In addtion, prob0 is recalculated every
8 symbols in each context. A context is rescaled by halving the counts of $0$ and $1$.

\begin{pseudo}{update\_context}{context,value}
\bsIF{value==\true}
    \bsCODE{context[count1] += 1}
\bsELSE
    \bsCODE{context[count0] += 1}
\bsEND
\bsIF( (context[count0]+context[count1])\%8==0)
    \bsIF{context[0]+context[1]== 256}
      \bsCODE{context[0] += 1}
      \bsCODE{context[0] \gg= 1}
      \bsCODE{context[1] += 1}
      \bsCODE{context[1] \gg= 1}
    \bsEND
    \bsCODE{calc\_prob0(context)}
\bsEND
\end{pseudo}

The probability of zero is recalculated to approximate
\[ \frac{context[count0]*2^{16}}{context[count0]+context[count1]}\]
to 16 bit accuracy:

\begin{pseudo}{calc\_prob0}{context}
\bsCODE{weight = context[count0]+context[count1]}
\bsCODE{inverse\_weight=(2^{16}+(weight//2))//weight}
\bsCODE{context[prob0]=context[count0]*inverse\_weight}
\end{pseudo}

\begin{informative}
Note that since $context[count0]<weight$, $context[prob0]$ is always a 16 bit unsigned quantity.
The inverse weight may easily be stored within a look-up table.
\end{informative}

\subsection{Initialisation}
\label{initarith}

At the beginning of the decoding of any data unit, the arithmetic
decoding state is initialised as follows:

\begin{pseudo}{initialise\_arithmetic\_decoding}{block\_data\_length}
\bsCODE{\ABitsLeft=8*block\_data\_length}
\bsCODE{\ALow = \text{0x0}}
\bsCODE{\ARange =\text{0x10000}}
\bsCODE{\ACode =\text{ 0x0}}
\bsFOR{i=0}{15}
    \bsCODE{\ACode <<= 1}
    \bsCODE{\ACode+= read\_bitb()} 
\bsEND
\bsCODE{init\_contexts()}
\end{pseudo}

Contexts are initialised by the $init\_contexts()$ function as follows:

\begin{pseudo}{init\_contexts}{}
\bsFOR{i=0}{length(\AContexts)-1}
  \bsCODE{\AContexts[i][count0]=1}
  \bsCODE{\AContexts[i][count1]=1}
  \bsCODE{\AContexts[i][prob0]=0x8000}
\bsEND
\end{pseudo}

\subsection{Data input}
\label{inputarith}

The arithmetic decoding process accesses data in a contiguous block of bytes
whose size is set on initialisation (Section \ref{initarith}). The bits in this
block are sufficient to allow for the
decoding of all coefficients. However, the specification of arithmetic
decoding operations in this section may occasionally cause further bits to be read,
even though they are not required for determining decoded values. For this
reason the bounded-block read function $read\_bitb()$ (Section \ref{blockreadbit}) is 
used for data access.

Since the length of arithmetically coded data elements is given in bytes within the Dirac
stream, there may be bits left unread when all values have been extracted. These
are flushed as desribed in Section \ref{blockreadbit}. Since arithmetically coded blocks
are byte-aligned and a whole number of bytes, this aligns data input with the beginning of the byte 
after the arithmetically coded data i.e. at the end of the
data chunk. $flush\_inputb()$ is always called at the end of decoding an arithmetically encoded
data element.

\begin{informative}
The Dirac arithmetic decoding engine uses 16 bit words, and so if all coefficients are
coded no more than 16 additional bits should be read beyond the end of the block. Hence it 
would seem sufficient to read in the entire block of data and pad the end with two bytes of value 0xFF,
to avoid a branch condition on inputting data
However, an arithmetically encoded block may end with a string of 1s, which an encoder could
conceivably strip out to save bits, in the knowledge that $read\_bitb()$ will re-insert them. Terminating
strings of 1s can occur (but not exclusively) in coding many zero wavelet subband coefficients at the end
of a subband. So a much larger number of pad bytes may be required in practice.
\end{informative}

\subsection{Decoder functions}
\label{extractarith}
The arithmetic decoding engine is a multi-context, adaptive binary
arithmetic decoder, performing binary renormalisation and producing
binary outputs. For each bit decoded, the semantics of the relevant
calling decoder function determine which contexts are passed to the
arithmetic decoding operations.

\subsubsection{Decoding boolean values}

\label{arithreadbool}

This section specifies the operation of the $read\_boola()$ function
for extracting a boolean value from the Dirac stream. The overall decoding
process is defined for extracting a symbol is as defined by the following
pseudocode:

\begin{pseudo}{read\_boola}{context\_index}
\bsCODE{context=\AContexts[context\_index]}
\bsCODE{count = \ACode-\ALow+1}
\bsCODE{range\_times\_prob = (\ARange * context[prob0])\gg 16}
\bsIF{ count > range\_times\_prob }
  \bsCODE{value = \true}
  \bsCODE{\ALow +=  range\_times\_prob}
  \bsCODE{\ARange -= range\_time\_prob}
\bsELSE
  \bsCODE{value = \false}
  \bsCODE{\ARange = range\_times\_prob}
\bsEND
\bsCODE{update\_context(\AContexts[context\_index],value)}
\bsCODE{renormalise()}{\ref{renormalisation}}
\bsEND
\bsRET(value)
\end{pseudo}

\begin{informative}
[Describe what's going on here]
\end{informative}

\subsubsection{Renormalisation}
\label{renormalisation}

Renormalisation is applied to stop the arithmetic decoding engine from losing accuracy: the range
must not get too small to allow 0 and 1 to be distinguished. Renormalisation is applied while the
range is less than or equal to a quarter of the total available 16-bit  range:

\begin{pseudo}{renormalise}{}
\bsWHILE{\ARange<=\text{0x4000}}
    \bsIF{(\ALow+\ARange-1)^\ALow>=\text{0x8000}}
        \bsCODE{resolve\_straddle()}
    \bsEND
    \bsCODE{shift\_bits()}
\bsEND
\end{pseudo}

\begin{informative}
Let the bottom of the arithmetic coding interval is represented by $low=\ALow$ and the top by $high=\ALow+\ARange-1$.
When the range is one quarter or less of the original range ($2^{16}$), then one of three possibilities occurs:
\begin{enumerate}
\item the top bits of $low$ and $high$ are both 0
\item the top bits of $low$ and $high$ are both 1
\item $low=b01...$, $high=b10....$,  and the interval straddles the half-way point 0x8000. 
\end{enumerate}

In all of these cases the interval can be doubled in size to increase accuracy. In the first case, it is doubled from zero ($x\mapsto 2*x$); 
in the second it is doubled from 1 ($x\mapsto 2*x-1$); and in the third it is doubled from 1/2 ($x\mapsto 2x-0.5$).
 
\end{informative}

\begin{pseudo}{resolve\_staddle}{}
\bsCODE{\ACode ^= \text{0x4000}}
\bsCODE{\ALow ^= \text{0x4000}}
\end{pseudo}

\begin{pseudo}{shift\_bits}{}
\bsCODE{\ALow  <<=  1}
\bsCODE{\ARange  <<=  1}
\bsCODE{\ALow \&= \text{0xFFFF}}
\bsCODE{\ACode <<= 1}
\bsCODE{\ACode+= read\_bitb()}
\bsCODE{\ACode \&= \text{0xFFFF}}
\end{pseudo}

\begin{comment}

\begin{informative}
The function scales the probability of the symbol $0$ from the decoding context
so that if this probability were $1$, then the interval would equal that between
 $\ALow$ and $\AHigh$. If $\ACode$ is greater than this cut-off, then 1 ($\true$) has
been encoded, else 0 ($\false$) has.
\end{informative}

\subsubsection{Shifting bits in}

\label{arithshiftin}

This section defines the operation of the $shift\_bit\_in()$ 
and $shift\_all\_bits()$ functions
for reading bits into the arithmetic decoding state variables.

\begin{pseudo}{shift\_bit\_in}{}
\bsCODE{\AHigh \ll= 1}
\bsCODE{\AHigh \&= \text{0xFFFF}}
\bsCODE{\AHigh += 1}
\bsCODE{\ALow \ll= 1}
\bsCODE{\ALow \&= \text{0xFFFF}}
\bsCODE{\ACode \ll= 1}
\bsCODE{\ACode \&= \text{0xFFFF}}
\bsCODE{\ACode += read\_bitb()}{\ref{blockreadbit}}
\end{pseudo}

$shift\_all\_bits()$ expands the interval between $\ALow$ and $\AHigh$
until the msbs (bit 15) differ and the interval no longer
straddles the half-way point 0x8000.

\begin{pseudo}{shift\_all\_bits}{}
\bsWHILE{ \AHigh\&\text{0x8000})==\text{0x0} \text{ and } (\ALow\&\text{0x8000})==\text{0x0}}
  \bsCODE{shift\_bit\_in()}
\bsEND
\bsWHILE{ (\AHigh\&\text{0x4000})==\text{0x0} \text{ and } (\ALow\&\text{0x4000})==\text{0x4000} }
  \bsCODE{\ACode \wedge= \text{0x4000}}
  \bsCODE{\AHigh \wedge= \text{0x4000}}
  \bsCODE{\ALow \wedge= \text{0x4000}}
  \bsCODE{shift\_bit\_in()}
\bsEND
\end{pseudo}

\begin{informative}
Note that if 16-bit words (unsigned shorts) are used for decoder state variables $\ALow$,
 $\AHigh$ and $\ACode$ then there is no need for {\&}-ing with 0xFFFF. However, the 
operations specified here are defined in terms of integers, since intermediate calculations
 require higher dynamic range. In software, the efficiency of using short word lengths may
or may not be offset by the requirement to cast to other data types for these calculations.
\end{informative}

\end{comment}

\subsubsection{Arithmetic decoding of integer values}

\label{arithreadint}

This section defines the operation of the $read\_sinta(context\_set)$ function
 for extracting integer values from a block of arithmetically coded data.

\paragraph{Binarisation and contexts \\}

Signed and unsigned integer values are binarised using interleaved exp-Golomb
 binarisation as per Section \ref{vlc}: the $read\_sinta()$ and $read\_uinta()$
processes are essentially identical to the 
$read\_sint()$ and $read\_uint()$ processes, except that instances of $read\_bool()$ are replaced
by instances of $read\_boola()$ (Section \ref{arithreadbool}) using suitable contextualisation. 

A choice of context depends upon whether the bit is a data bit, follow bit, or sign bit, and upon the 
position of the bit within the binarisation: $context\_set$ consists of three parts -
\begin{itemize}
\item an array of follow contexts, $context\_set[follow]$ (indexed from 0 to 
$\length(context\_set[follow])-1$)
\item a single data context $context\_set[data]$ 
\item a sign context $context\_set[sign]$ (ignored for unsigned integer decoding)
\end{itemize}

Each follow context is used for decoding the corresponding follow bit, with the
last follow context being used for all subsequent follow bits (if any) also. 
The follow context selection function $follow\_context()$ is defined by:

\begin{pseudo}{follow\_context}{index, context\_set}
\bsCODE{pos= max(index, length(context\_set[follow])-1 }
\bsCODE{ctx\_index = context\_set[follow][pos]}
\bsRET{\Contexts[ctx\_index]}
\end{pseudo}

So the last follow context is used for all the remaining follow bits also.

\paragraph{Unsigned integer decoding \\}

Unsigned integers are decoded by:

\begin{pseudo}{read\_uinta}{context\_set}
\bsCODE{value = 1}
\bsCODE{index = 0}
\bsWHILE{read\_boola(follow\_context(index,context\_set) )== \false}
  \bsCODE{value \ll = 1}
  \bsIF{read\_boola(\text{state[contexts]}[context\_set[data])])}
    \bsCODE{value += 1}
  \bsEND
  \bsCODE{index += 1}
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

\paragraph{Signed integer decoding \\}

$read\_sinta()$ decodes first the magnitude then the sign, as necessary:

\begin{pseudo}{read\_sinta}{context\_set}
\bsCODE{value=read\_uinta(context\_set)}
\bsIF{value != 0}
  \bsIF{read\_boola(\Contexts[context\_set[sign])]) == \true}
    \bsCODE{value=-value}
  \bsEND
\bsEND
\bsRET{value}
\end{pseudo}

\subsection{Context indices}
\label{contextindices}

The following is a list of all the context indices used in Dirac arithmetic decoding operations:

Wavelet coefficient contexts:

\SignZero\\
\SignPos\\
\SignNeg\\
\ZPZNFollowOne\\
\ZPNNFollowOne\\
\ZPFollowTwo\\
\ZPFollowThree\\
\ZPFollowFour\\
\ZPFollowFive\\
\ZPFollowSixPlus\\
\NPZNFollowOne\\
\NPNNFollowOne\\
\NPFollowTwo\\
\NPFollowThree\\
\NPFollowFour\\
\NPFollowFive\\
\NPFollowSixPlus\\
\CoeffData\\
\ZeroCodeblock\\
\QOffsetFollow\\
\QOffsetData\\
\QOffsetSign\\

Motion data contexts:

\SBSplitFollowOne\\
\SBSplitFollowTwo\\
\SBSplitData\\
\PredModeOne\\
\PredModeTwo\\
\BlockGlobal\\
\VectorFollowOne\\
\VectorFollowTwo\\
\VectorFollowThree\\
\VectorFollowFour\\
\VectorFollowFivePlus\\
\VectorData\\
\VectorSign\\
\DCFollowOne\\
\DCFollowTwoPlus\\
\DCData\\
\DCSign\\
