%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how wavelet coefficients - %
% - are decoded                                   - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{transformdec}

This section specifies the overall operation of the $core\_transform\_data(comp)$ process
for unpacking the set of coefficient subbands corresponding
to a video picture component (Y, C1 or C2) in the core Dirac syntax, 
according to the conventions set out in Section \ref{wltdecodeconventions}.

In the Dirac stream core syntax, subband data is arranged by 
level and orientation, from level 0 up to level \TransformDepth. Coefficients may
be VLC or arithmetic coded. Where arithmetic coding is used, the unpacking process
 for each subband is contingent on data from subbands of the same orientation in 
 the next lower level. This is the {\em parent} subband; the subband of the same orientation in the next
higher level is the {\em child} subband. 

Unpacking an individual subband therefore requires prior unpacking of the parent subband,
and of its parent, and so on until level 1 is reached (level 1 subbands do not depend
upon the single level 0 DC band).

\begin{informative}
The data for each subband consists of a subband header and a block of arithmetically
coded coefficient data. The subband header contains a length code giving the number of
bytes of the block of arithmetically-coded data. The transform data can therefore be
parsed without invoking arithmetic decoding at all, since the length codes allow a 
parser to skip from one subband header to the next, similarly to the way that parse unit
offsets allow frame skipping.
\end{informative}


\subsubsection{Overall process}
The overall $core\_transform\_data()$ process is as follows:

\begin{pseudo}{core\_transform\_data}{comp}
\bsCODE{data=initialise\_wavelet\_data(comp)}{\ref{wltinit}}
\bsCODE{subband(data, 0, \LL)}{\ref{subbanddecodeprocess}}    
\bsFOR{level=1}{\TransformDepth}
  \bsFOREACH{orient}{\HL,\LH,\HH}
    \bsCODE{byte\_align()}
    \bsCODE{subband(data, level, orient)}{\ref{subbanddecodeprocess}}
  \bsEND
\bsEND
\bsRET{data}
\end{pseudo}

\subsubsection{Subbands}

\label{subbanddecodeprocess}

This section specifies the process $subband(data, level,orient)$ for unpacking coefficients
within a subband at level $level$ ($0$ to \TransformDepth) and of orientation $orient$
(\LL, \LH, \HL, or \HH). 

The overall process consists of reading a byte-aligned header for each
subband, including a length code for the subsequent arithmetically-coded data.
Subband data is initialised to 0. If the length code is 0, the subband may be 
skipped and all data remains set to zero.
Intra DC bands are predicted, and so must additionally be reconstructed.

\begin{pseudo}{subband}{data, level, orient}
\bsITEM{length}{uint}
\bsCODE{zero\_subband\_data(data[level][orient])}{\ref{zerosubband}}
\bsIF{length == 0}
  \bsCODE{byte\_align()}
\bsELSE
    \bsCODE{quant\_index = read\_uint()}
    \bsCODE{byte\_align()}
    \bsCODE{subband\_coeffs(data,level,orient,length,quant\_index)}{\ref{subbandcoeffs}}
\bsEND 
\bsIF{is\_intra() \text{ and } level==0}
    \bsCODE{intra\_dc\_prediction(data[level][orient])}{\ref{intradcprediction}}
\bsEND
\end{pseudo}

\paragraph{Zero subband}
\label{zerosubband}
$\ $\newline$\ $\newline
The $zero\_subband()$ process sets all subband coefficients to 0. When
a subband or codeblock is skipped, all coefficients within the codeblock
will remain 0. 

\begin{pseudo}{zero\_subband\_data}{band}
\bsFOR{y=0}{\height(band)-1}
  \bsFOR{x=0}{\width(band)-1}
    \bsCODE{band[y][x] = 0}
  \bsEND
\bsEND
\end{pseudo}

\paragraph{Non-skipped subbands}
\label{subbandcoeffs}
$\ $\newline$\ $\newline
Data within subbands is split into one or more rectangular codeblocks (Figure \ref{codeblocks}).
Codeblocks are scanned in raster order across the subband and coefficients are scanned in raster order
within each codeblock. 

\begin{figure}
[Include codeblock figure \label{codeblocks}]
\end{figure}

The overall unpacking process is therefore:

\begin{pseudo}{subband\_coeffs}{data,level,orient,length}
\bsCODE{initialise\_arithmetic\_decoding(length)}{\ref{initarith}}
\bsFOR{y=0}{\Codeblocks[level][v]-1}
    \bsFOR{x=0}{\Codeblocks[level][h]-1}
        \bsCODE{codeblock(data,level,orient,quant\_index,y,x)}{\ref{codeblocks}}
    \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\begin{informative}
Note that even if arithmetic coding is not being used for coefficient unpacking,
the arithmetic decoding engine is still initialised to ensure that $\ABitsLeft$ is set
to allow the bounded read function $read\_sintb()$ to operate correctly. 
\end{informative}

\paragraph{Intra DC band prediction}
\label{intradcprediction}
$\ $\newline
This section defines the operation of the $intra\_dc\_prediction(band)$ function
for reconstructing values within Intra picture DC bands using spatial prediction.
This function is applied once all coefficients in all codeblocks within the DC
band have been unpacked, although it may be applied progressively to each coefficient
as soon as it has been unpacked.

Intra DC values are derived by spatial prediction using the mean of the
three values to the left, top-left and above a coefficient (if available).

\begin{pseudo}{intra\_dc\_prediction}{band}
\bsCODE{prediction = 0 }
\bsFOR{v=0}{subband\_height(level)-1}
  \bsFOR{h=0}{subband\_width(level)-1}
    \bsIF{h>0}
        \bsIF{v>0}
            \bsCODE{prediction=\mean(band[v][h-1],band[v-1][h-1],band[v-1][h])}
        \bsELSE
            \bsCODE{prediction=band[0][h-1]}
        \bsEND
    \bsELSE
        \bsIF{v>0}
            \bsCODE{prediction=band[v-1][0]}
        \bsELSE
            \bsCODE{prediction = 0}
        \bsEND
    \bsEND
    \bsCODE{band[v][h] += prediction}
  \bsEND
\bsEND
\end{pseudo}

\subsubsection{Subband codeblocks}
\label{codeblocks}

This section defines the operation of the 
$codeblock(band,parent,level, orient,quant\_index,y,x)$ function, which unpacks
coefficients within a 
codeblock in position $(x,y)$.

\begin{comment}
[Include a figure here]
\end{comment}

\paragraph{Codeblock dimensions}
$\ $\newline

The codeblock covers coefficients in the horizontal range $left$ to $right-1$ and in the vertical
range $bottom$ to $top-1$ where these values are defined by:
\begin{eqnarray*}
  left & = & (\width(band)*x)//\Codeblocks[level][horizontal] \\
  right & = & (\width(band)*(x+1))//\Codeblocks[level][horizontal] \\
  bottom & = & (\height(band)*y)//\Codeblocks[level][vertical] \\
  top & = & (\height(band)*(y+1))//\Codeblocks[level][vertical]
\end{eqnarray*}

\paragraph{Codeblock unpacking loop}
$\ $\newline$\ $\newline
The codeblock unpacking process is defined as:

\begin{pseudo}{codeblock}{data,level,orient,quant\_index,y,x}
\bsCODE{skipped=zero\_flag()}{\ref{zeroblockflag}}
\bsIF{skipped==\false}
  \bsCODE{quant\_idx += quant\_offset()}{\ref{blockquantidx}}
  \bsFOR{v=bottom}{top-1}
    \bsFOR{h=left}{right-1}
      \bsIF{using\_ac()==\true}
          \bsCODE{coeff\_unpack(data,level,orient,quant_idx,v,h)}{\ref{wltcoeff}}
      \bsELSE
          \bsCODE{data[level][orient][v][h]=read\_sintb()}{\ref{segol}}
      \bsEND
    \bsEND
  \bsEND
\bsEND

\end{pseudo}

If the codeblock is skipped, then coefficients within that codeblock remain 0.

\begin{informative}
If arithmetic coding is not employed, the use of the bounded read operation ensures
that a subband may, if desired, be terminated early and all remaining coefficients
will be 0.
\end{informative}

\paragraph{Skipped codeblock flag}
\label{zeroblockflag}
$\ $\newline$\ $\newline
If the number of codeblocks is 1, then $zero\_flag()$ is set to $\false$, else
it is unpacked from the stream.

\begin{pseudo}{zero\_flag}{}
\bsCODE{num\_blocks=
\begin{array}{l}
\Codeblocks[level][horizontal]* \\
\Codeblocks[level][vertical]
\end{array} }
\bsIF{num_blocks==1}
    \bsRET{\false}
\bsELSE
    \bsRET{ read\_boola(\ZeroCodeblock) }
\bsEND
\end{pseudo}

\paragraph{Block quantiser offset}
$\ $\newline$\ $\newline
\label{blockquantidx}

If $\CodeblockMode=\SingleQuantiser$,  $quant\_offset()$ shall return 0.

If $\CodeblockMode=\MultipleQuantiser$ then the quantiser index offset
is extracted from the stream -- $read\_sinta(quant\_contexts())$ is returned, where
$quant\_contexts()$ returns the context set:

\begin{itemize}
\item{Follow= \{\QOffsetFollow\}}
\item{Data=\QOffsetData}
\item{Sign=\QOffsetSign}
\end{itemize}

\subsubsection{Subband coefficients}

\label{wltcoeff}

This section describes the operation of the 
$coeff\_unpack(data,level,orient,quant\_idx,v,h)$ process
for unpacking an individual coefficient in position $(h,v)$ 
in the subband $data[level][orient]$.

Unpacking a coefficient makes use of arithmetic decoding, inverse quantisation
and, in the case of DC (level 0) bands of Intra frames, neighbourhood prediction.

Arithmetic coding uses a highly compact set of contexts, 
with magnitudes contextualised on whether parent values
and neighbouring values are zero or non-zero.

\paragraph{Overall process}
$\ $\newline
The overall process for unpacking an individual coefficient is:

\begin{pseudo}{coeff\_unpack}{data,level,orient,quant\_index,v,h}
    \bsCODE{parent = parent\_val(data,level,orient, v, h)}{\ref{parentval}}
    \bsCODE{nhood = zero\_nhood(data[level][orient],v,h)}{\ref{zeronhood}}
    \bsCODE{sign\_pred = sign\_predict(data[level][orient],orient,v,h)}{\ref{signpredict}}
    \bsCODE{context\_set = select\_coeff\_ctxs(nhood, parent, sign\_pred)}{\ref{selectcoeffcontext}}
    \bsCODE{quant\_coeff = read\_sinta( context\_set )}{}
    \bsCODE{data[level][orient][v][h] = inverse\_quant( quant\_coeff, quant\_index )}{\ref{invquant}}
\end{pseudo}

\paragraph{Parent values}
\label{parentval}
$\ $\newline
The function $parent\_val(data,level,orient,v, h)$ returns the parent value of a coefficient in a subband,
which is the co-located coefficient in the parent subband, if there is one. There is deemed to be a 
parent subband if $level\geq 2$:

\begin{pseudo}{parent}{data,level,orient,v,h}
\bsIF{level>=2}
    \bsCODE{parent = data[level-1][orient][v//2][h//2]}
\bsELSE
    \bsCODE{parent = 0}
\bsEND
\bsRET{parent}
\end{pseudo}

\paragraph{Zero neighbourhood}
\label{zeronhood}
$\ $\newline
The $zero\_nhood()$ function returns a boolean indicating whether neighbouring
values are all zero.

\begin{pseudo}{zero\_nhood}{band,v,h}
\bsIF{v>0}
  \bsIF{band[v-1][h]!=0}
    \bsRET{\false}
  \bsEND
  \bsIF{h>0}
    \bsIF{band[v-1][h-1])!=0 \text{ or } band[v][h-1]!=0}
      \bsRET{\false}
    \bsEND
  \bsEND
\bsELSE
  \bsIF{h>0}
    \bsIF{ band[v][h-1] !=0}
      \bsRET{\false}
    \bsEND
  \bsEND
\bsEND
\bsRET{\true}
\end{pseudo}

\paragraph{Sign prediction}
\label{signpredict}
$\ $\newline
The $sign\_predict()$ function returns a prediction for the sign of the 
current pixel. Correlation within subbands depends upon orientation,
and so this is taken into account in forming the prediction.

For vertically-oriented (HL) bands, the predictor is the sign of the
coefficient above the current coefficient; for horizontally-oriented (LH)
bands, the predictor is the sign of the coefficient to the left. 

The predictions are not used for differential encoding of the sign, but for
conditioning of the sign contexts only.

\begin{pseudo}{sign\_predict}{band,orient,v,h}
\bsIF{orient==HL}
  \bsIF{v==0}
    \bsRET{0}
  \bsELSE
    \bsRET{\sign(band[v-1][h])}
  \bsEND
\bsELSEIF{orient==LH}
  \bsIF{h==0}
    \bsRET{0}
  \bsELSE
    \bsRET{\sign(band[v][h-1])}
  \bsEND
\bsELSE
  \bsRET{0}
\bsEND{}
\end{pseudo}

\paragraph{Coefficient context selection}
\label{selectcoeffcontext}
$\ $\newline
This section defines the $select\_coeff\_ctxs(zero\_nhood, parent, sign\_pred)$
function, which chooses a context index set for unpacking a coefficient value.

Twelve possible coefficient index sets are defined, and are returned as specified 
in Table \ref{contexttable}. Note that follow contexts are an array indexed from $0$
as per Section \ref{arithreadint}.

Note that parent values affect the context of all follow bits, and that neighbour
values only affect the context of the first follow bit. A common data context is used
for all coefficients.

%% Table of context sets for signed coefficient extraction %%
\begin{table}[!ht]
\begin{tabular}{|c|c|c||l|l|}
\hline
 $parent$ & $zero\_nhood$ & $sign\_pred$ & \multicolumn{2}{c|}{\bf{Context set}} \\

% Zero parent, zero neighbour, zero sign prediction
\hline
0 & \true & 0 &  Follow & [\ZPZNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                            \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &   &   &  Data & \CoeffData \\ \cline{4-5}
  &   &   &  Sign & \SignZero \\

% Zero parent, zero neighbour, -ve sign prediction
\hline
0 & \true & $<0$ &  Follow & [\ZPZNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                               \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &   &    &  Data & \CoeffData \\ \cline{4-5}
  &   &    &  Sign & \SignNeg \\

% Zero parent, zero neighbour, +ve sign  prediction
\hline
0 & \true & $>0$ &  Follow & [\ZPZNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                               \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &   &    &  Data & \CoeffData \\ \cline{4-5}
  &   &    &  Sign & \SignPos \\

% Zero parent, non-zero neighbour, zero sign prediction
\hline
0 & \false & 0 &  Follow & [\ZPNNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                             \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &   &   &  Data & \CoeffData \\ \cline{4-5}
  &   &   &  Sign & \SignZero \\

% Zero parent, non-zero neighbour, -ve sign prediction
\hline
0 & \false & $<0$ &  Follow & [\ZPNNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                                \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &        &    &  Data & \CoeffData \\ \cline{4-5}
  &        &    &  Sign & \SignNeg \\

% Zero parent, non-zero neighbour, +ve sign prediction
\hline
0 & \false & $>0$ &  Follow & [\ZPNNFollowOne,\ZPFollowTwo,\ZPFollowThree,
                                \ZPFollowFour,\ZPFollowFive,\ZPFollowSixPlus] \\ \cline{4-5}
  &        &      &  Data & \CoeffData \\ \cline{4-5}
  &        &      &  Sign & \SignPos \\

% Non-zero parent, zero neighbour, zero sign prediction
\hline
$\neq 0$ &  \true & 0 & Follow & [\NPZNFollowOne,\NPFollowTwo,\NPFollowThree,
                                    \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignZero \\

% Non-zero parent, zero neighbour, -ve sign prediction
\hline
$\neq 0$ & \true & $<0$ &  Follow & [\NPZNFollowOne,\NPFollowTwo,\NPFollowThree,
                                      \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignNeg \\

% Non-zero parent, zero neighbour, +ve sign prediction
\hline
$\neq 0$ & \true & $>0$ &  Follow & [\NPZNFollowOne,\NPFollowTwo,\NPFollowThree,
                                      \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignPos \\

% Non-zero parent, non-zero neighbour, zero sign prediction
\hline
$\neq 0$ & \false & 0 &  Follow & [\NPNNFollowOne,\NPFollowTwo,\NPFollowThree,
                                    \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignZero \\

% Zero parent, non-zero neighbour, -ve sign prediction
\hline
$\neq 0$ & \false & $<0$ &  Follow & [\NPNNFollowOne,\NPFollowTwo,\NPFollowThree,
                                       \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignNeg \\

% Zero parent, non-zero neighbour, +ve sign prediction
\hline
$\neq 0$ & \false  & $>0$ &  Follow & [\NPNNFollowOne,\NPFollowTwo,\NPFollowThree,
                                        \NPFollowFour,\NPFollowFive,\NPFollowSixPlus] \\ \cline{4-5}
& &      &  Data & \CoeffData \\ \cline{4-5}
& &      &  Sign & \SignPos \\
\hline

\end{tabular}
\caption{Subband coefficient context sets}\label{contexttable}
\end{table}
