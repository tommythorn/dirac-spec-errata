%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines the overall process  - %
% - for decoding a picture                    - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{picturedec}

This section defines the processes for decoding a picture from a Dirac stream. 
Picture decoding depends upon correctly parsing the stream, and decoding operations
 are dependent on decoding the sequence header and picture metadata 
(Section \ref{sequenceheader} and \ref{picturesyntax}) and unpacking the coefficient 
and motion data (Sections \ref{wltunpacking} and \ref{motiondec}).

\subsection{Overall picture decoding process}
\label{overallpicturedec}

Picture data from the current picture being decoded is stored in the $\CurrentPicture$ state
variable, which is a map with labels $pic\_num$, and $Y$, $C1$ and $C2$ representing
luma and chroma data.

After decoding the decoded picture is returned to the decoding application.

The $picture\_decode()$ process shall be invoked after parsing the $picture\_parse()$ process and shall be defined as follows:

\begin{pseudo}{picture\_decode}{}
\bsCODE{\CurrentPicture={}}
\bsCODE{\CurrentPicture[pic\_num]=\PictureNumber}
\bsIF{is\_ref(()}
    \bsCODE{ref\_buffer\_remove()}{\ref{refbuffer}}
\bsEND
\bsIF{\ZeroResidual==\false}
    \bsCODE{inverse\_wavelet\_transform}{\ref{}}
\bsEND
\bsIF{is\_inter()}
    \bsCODE{ref1=get\_ref(\RefOneNum)}{\ref{refbuffer}}
    \bsIF{num\_refs()==2}{\ref{parseinfo}}
        \bsCODE{ref2=get\_ref(\RefTwoNum)}{\ref{refbuffer}}
    \bsEND
    \bsCODE{motion\_compensate(ref1[Y], ref2[Y],  \CurrentPicture[Y], c)}{\ref{motioncompensate}}
    \bsCODE{motion\_compensate(ref1[C1], ref2[C1],  \CurrentPicture[C1], c)}{\ref{motioncompensate}}
    \bsCODE{motion\_compensate(ref1[C2], ref2[C2],  \CurrentPicture[C2], c)}{\ref{motioncompensate}}
\bsEND
\bsCODE{clip\_picture()}{\ref{pictureclip}}
\bsIF{is\_ref()}
    \bsCODE{ref\_buffer\_add()}{\ref{refbuffer}}
\bsEND
\bsCODE{offset\_output\_picture(\CurrentPicture)}{\ref{videooutput}}
\bsRET{\CurrentPicture}
\end{pseudo}

 
\begin{informative}
When randomly accessing a sequence, a picture may not be decodeable 
because reference pictures may not be available in the buffer. In this case the 
current picture may be discarded, although some decoders may be designed to 
produce an output. 

Picture numbers within the stream may not be in numerical order, and 
subsequent reordering may be required: the size of the decoded picture buffer 
required to perform any such reordering is specified as part of the application profile 
and level (Appendix \ref{profilelevel}).
\end{informative}

\subsection{Reference picture buffer management}
\label{refbuffer}

This section specifies how the Dirac stream data shall be used to manage the reference 
picture buffer $\RefBuffer$. The reference picture buffer has a maximum size of
$\RefBufferSize$ elements, as set in the applicable level (Appendix \ref{profilelevel}).

The $ref\_picture\_remove()$ process shall be defined as
follows:

\begin{pseudo}{ref\_picture\_remove}{}
\bsCODE{n=\RetiredPicture}
\bsFOR{k=0}{\RefBufferSize-1}
   \bsIF{\RefBuffer[k][pic\_number]==n}
        \bsFOR{j=k}{\RefBufferSize-2}
            \bsCODE{\RefBuffer[j]=\RefBuffer[j+1]}
        \bsEND
        \bsCODE{\RefBufferSize -= 1}
    \bsEND
\bsEND
\end{pseudo}

The $get\_ref(n)$ function shall returns the reference picture in the buffer with 
picture number $n$.  If there is no such picture it shall return an all-zero picture.

The $ref\_picture\_add()$ process for adding pictures to the reference picture
buffer shall proceed according to the following rules:

{\bf Case 1.} If the reference picture buffer is not full i.e. has fewer than $\MaxRefBufferSize$ elements,
then add $\CurrentPicture$ to the end of the buffer. 

{\bf Case 2.} If the reference picture is full i.e. it has $\MaxRefBufferSize$ elements, then remove the
first (i.e. oldest) element of the buffer, $\RefBuffer[0]$, set
\[\RefBuffer[i] = \RefBuffer[i+1] \]
for $i=0$ to $\RefBufferSize-2$, and set the last element $\RefBuffer[\RefBufferSize-1]$ equal to
a copy of $\CurrentPicture$.

\input{idwt}

\subsection{Motion compensation}
\input{mc}

\subsection{Clipping}
\label{pictureclip}

Picture data must be clipped prior to being output or being
used as a reference:

\begin{pseudo}{clip\_picture}{}
\bsFOREACH{c}{Y,C1,C2}
    \bsCODE{clip\_component(\CurrentPicture[c])}
\bsEND
\end{pseudo}


\begin{pseudo}{clip\_component}{comp\_data,c}
\bsIF{c==Y}
    \bsCODE{bit\_depth=\LumaDepth}
\bsELSE
    \bsCODE{bit\_depth=\ChromaDepth}
\bsEND
\bsFOR{y=0}{\height(comp\_data)-1}
    \bsFOR{x=0}{\width(comp\_data)-1}
        \bsCODE{data = \clip(comp\_data[y][x], -2^{bit\_depth-1}, 2^{bit\_depth-1}-1)}
     \bsEND
\bsEND
\end{pseudo}

\begin{informative}
Note that clipping is incorporated into motion compensation, so that strictly speaking additional
clipping is only required for intra pictures.
\end{informative}


\subsection{Clipping}
\label{pictureclip}

Picture data must be clipped prior to being output or being
used as a reference:

\begin{pseudo}{clip\_picture}{}
\bsFOREACH{c}{Y,C1,C2}
    \bsCODE{clip\_component(\CurrentPicture[c])}
\bsEND
\end{pseudo}


\begin{pseudo}{clip\_component}{comp\_data,c}
\bsIF{c==Y}
    \bsCODE{bit\_depth=\LumaDepth}
\bsELSE
    \bsCODE{bit\_depth=\ChromaDepth}
\bsEND
\bsFOR{y=0}{\height(comp\_data)-1}
    \bsFOR{x=0}{\width(comp\_data)-1}
        \bsCODE{data = \clip(comp\_data[y][x], -2^{bit\_depth-1}, 2^{bit\_depth-1}-1)}
     \bsEND
\bsEND
\end{pseudo}

\begin{informative}
Note that clipping is incorporated into motion compensation, so that strictly speaking additional
clipping is only required for intra pictures.
\end{informative}

\subsection{Video output ranges}
\label{videooutput}

Video output data ranges are deemed to be non-negative, so that the offset and excursion values 
may be applied by subsequent processing. Since decoded video data is bipolar, it must be 
suitably offset before output:

\begin{pseudo}{offset\_output\_data}{picture\_data}
\bsFOREACH{c}{Y, C1, C2}
    \bsIF{c==Y}
        \bsCODE{bit\_depth=\LumaDepth}
    \bsELSE
        \bsCODE{bit\_depth=\ChromaDepth}
    \bsEND
    \bsCODE{comp=picture\_data[c]}
    \bsFOR{y=0}{\height{comp}-1}
        \bsFOR{x=0}{\width{comp}-1}
            \bsCODE{comp[y][x]+=2^{bit\_depth-1}}
        \bsEND
    \bsEND
\bsEND
\end{pseudo}