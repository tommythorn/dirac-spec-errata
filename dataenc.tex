%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how raw and VLC data  - %
% - is extracted                               - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Data is encoded in the Dirac bitstream in four basic ways: fixed-length
bit-wise and byte-wise encodings; variable-length codes; and arithmetic encoding.

This section defines how data bits are extracted from the bitstream and how
sequences of bits are interpreted as values of various types using fundamental
data-reading functions, covering encodings of the first two sorts. The extraction
of arithmetic-encoded data is defined in Section \ref{arithdecoding}.

\subsection{Bit-packing and data input}
\label{bitpacking}

This section defines the operation of the $read\_bit()$, $read\_byte()$ 
and $byte\_align()$ functions used for direct access to the Dirac stream.

Access to the Dirac stream is bytewise, and a decoder is deemed to maintain
a copy of the current byte, $\CurrentByte$, and an index to the next bit
to be read, $\NextBit$. $\NextBit$ is an integer from 0 (least-significant bit) to 7 
(most-significant bit). Bits within bytes are accessed from the msb first to the
lsb.

Each access unit and individual picture is a whole number of bytes. Decoding from the
start of an access unit, $\NextBit$ is set to 7.

The $read\_byte()$ function performs the following steps --
\begin{enumerate}
\item Sets $\NextBit=7$ 
\item Sets $\CurrentByte$ to the next unread byte in the Dirac stream
\end{enumerate}

The $read\_bit()$ function is defined by

\begin{pseudo}{read\_bit}{}
\bsIF{\NextBit == 7}
\bsCODE{read\_byte()}
\bsEND
\bsCODE{bit = ( \CurrentByte \gg \NextBit ) \& 1 }
\bsCODE{\NextBit -= 1}
\bsIF{\NextBit<0}
    \bsCODE{\NextBit == 7}
\bsEND
\bsRET{bit}
\end{pseudo}

The $byte\_align()$ function discards data in the current byte and begins data access
at the next byte, unless input is already at the beginning of a byte: 

\begin{pseudo}{byte\_align}{}
\bsCODE{\NextBit = 7}
\end{pseudo}

This is used to ensure that a whole number of bytes are read before
beginning reading a new stream element.

\subsection{Fixed-length code formats}
\subsubsection{Bool}

The $read\_bool()$ function returns --
\begin{itemize}
\item $\true$ if $read\_bit()$ is $1$
\item $\false$ if $read\_bit()$ is $0$
\end{itemize}

\subsubsection{n-bit literal}
An $n$-bit number in literal format shall be decoded by extracting $n$ bits
in order, using the $read\_bit()$ function (Section \ref{bitpacking})
 and placing the first bit in the leftmost position, the second
bit in the next position and so on. The resulting value is to be
interpreted as an unsigned integer:

\begin{pseudo}{read\_nbits}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_bit()}
    \bsCODE{val \ll = 1}
\bsEND
\bsRET{val}
\end{pseudo}

\subsubsection{$n$-byte unsigned integer literal}
A single byte may be interpreted as an unsigned integer value from 0 to 255.

An $n$-byte number in literal format shall be decoded by the recipe:

\begin{pseudo}{read\_uint\_lit}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_byte()}{\ref{bitpacking}}
    \bsCODE{val \ll = 8}
\bsEND
\bsRET{val}
\end{pseudo}

\subsection{Variable-length code formats}
\label{vlc}
Variable-length codes are used in three ways in the Dirac stream. The first
use is for direct encoding of header values into the stream. The second use
is for entropy coding of motion data and coefficients, where arithmetic decoding
is not in use.

The third use 
is for binarisation in the arithmetic encoding/decoding process so that integer 
values may be coded and decoded using a binary arithmetic coding engine. This is
described in Section \ref{arithdecoding}.

When used for coding motion data and coefficients, VLCs are employed within
a data block of known length. It is possible to gain additional compression by early termination:
maintaining a count of remaining bits, and returning default values when this length
is exceeded. This is achieved by use of the $read\_bitb()$, $read\_uintb()$ and $read\_sintb()$
for reading values from data blocks. A similar early termination facility is a used for
arithmetic decoding.

\subsubsection{Data input for block operation}
\label{blockreadbit}

This section specifies the operation of the $read\_bitb()$ process for reading bits from
a block of known size. In this case, the decoder state variable $\ABitsLeft$ has been
set to the block length, and is decremented on reading a bit. When all bits in the block
have been read, then $1$ is returned by default:

\begin{pseudo}{read\_bitb}{}
\bsIF{\ABitsLeft==0}
  \bsRET{1}
\bsELSE
  \bsCODE{\ABitsLeft -= 1}
  \bsRET{read\_bit()}
\bsEND
\end{pseudo}

It is possible that not all data in a block is exhausted after a sequence of read operations.
At the end of a sequence of read operations, the decoder will flush the block. This assists
with recovery in the event of errors in the stream, and enforces byte-alignment where required 
(for example in arithmetic coded blocks).

\begin{pseudo}{flush\_inputb()}{}
\bsWHILE{\ABitsLeft>0}
    \bsCODE{read\_bit()}
    \bsCODE{\ABitsLeft-=1}
\bsEND
\end{pseudo}


\subsubsection{Unsigned interleaved exp-Golomb codes}
This section defines the unsigned interleaved exp-Golomb data format and the operation
of the $read\_uint()$ and the $read\_uintb()$ functions. 

Unsigned interleaved exp-Golomb data is decoded to produce unsigned
 integer values.The format consists of two interleaved parts, 
and each code is an odd number, $2K+1$ bits in length.

The $K+1$ bits in the even positions (counting from zero) are the ``follow" bits, and 
the $K$ bits in the odd positions are the ``data" bits $b_i$ which are used to construct
the decoded value itself. A follow bit value of $0$ indicates a subsequent data bit,
whereas a follow bit value of $1$ terminates the code:
\begin{equation*}
0\quad b_{K-1}\quad 0\quad b_{K-2}\hdots 0\quad b_{0}\quad 1
\end{equation*}

The data bits $b_{K-1}, b_{K-2}, \hdots, b_0$ are the binary representation 
 of the first $K$ bits of the $(K+1)$-bit number 
$N+1$, where $N$ is the number to be decoded:
\begin{equation*}
N+1=1 b_{K-1} b_{K-2}\hdots b_0 \text{(base $2$)}
\end{equation*}

A table of encodings of the first 10 values is shown in Figure \ref{uegolcodings}.

\begin{figure}[h]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
1                 &  0\\
0 0 1             &  1\\
0 1 1             &  2\\
0 0 0 0 1         &  3\\
0 0 0 1 1         &  4\\
0 1 0 0 1         &  5\\
0 1 0 1 1         &  6\\
0 0 0 0 0 0 1     &  7\\
0 0 0 0 0 1 1     &  8\\
0 0 0 1 0 0 1     &  9\\
\end{tabular}

\caption{Example conversions from unsigned interleaved exp-Golomb-coded 
values to unsigned integers \label{uegolcodings}}
\end{figure}

Although apparently complex, the interleaving ensures that the code has a very simple decoding loop. 
The $read\_uint()$ function returns an unsigned integer value and is defined by the recipe:

\begin{pseudo}{read\_uint}{}
\bsCODE{value = 1}
\bsWHILE{read\_bit() == 0}
  \bsCODE{value \ll = 1}
  \bsIF{read\_bit()==1}
    \bsCODE{value += 1}
  \bsEND
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

\begin{informative}
Conventional exp-Golomb coding places all follow bits at the beginning as a prefix. This is
easier to read, but requires that a count of the prefix length be maintained. Values can only
be decoded in two loops -- the prefix followed by the data bits. Interleaved exp-Golomb 
coding allows values to be decoded in a single loop, without the need for a length count.
\end{informative}

The $read\_uintb()$ function is identical to $read\_uint()$ except that the block-bounded read
operation is employed:

\begin{pseudo}{read\_uintb}{}
\bsCODE{value = 1}
\bsWHILE{read\_bitb() == 0}
  \bsCODE{value \ll = 1}
  \bsIF{read\_bitb()==\true}
    \bsCODE{value += 1}
  \bsEND
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

Note that when $\ABitsLeft==0$, all subsequent values read by $read\_uintb()$ will be 0.

\subsubsection{Signed interleaved exp-Golomb}
\label{segol}

This section defines the signed interleaved exp-Golomb data format and the operation
of the $read\_sint()$ and $read\_sintb()$ functions.

The code for the signed interleaved exp-Golomb data format consists of the
unsigned interleaved exp-Golomb code for the magnitude, followed by a sign bit
for non-zero values (Figure \ref{segolcodings}).

\begin{figure}[h]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
1                 &  0\\
0 0 1 1           &  -1\\
0 0 1 0           &  1\\
0 1 1 1            &  -2\\
0 1 1 0            &  2\\
0 0 0 0 1 1         &  -3\\
0 0 0 0 1 0         &  3\\
0 0 0 1 1 1         &  -4\\
0 0 0 1 1 0         &  4\\
\end{tabular}

\caption{Example conversions from signed interleaved exp-Golomb-coded values 
to signed integers \label{segolcodings}}
\end{figure}

The decoding operation is as follows.

\begin{pseudo}{read\_sint}{}
\bsCODE{value = read\_uint()}
\bsIF{read\_bit()==1}
  \bsCODE{value = -value}
\bsEND
\bsRET{value}
\end{pseudo}

The $read\_sintb()$ function is identical to $read\_sint()$ except that the block-bounded read
operation is employed:

\begin{pseudo}{read\_sintb}{}
\bsCODE{value = read\_uintb()}
\bsIF{read\_bitb()==1}
  \bsCODE{value = -value}
\bsEND
\bsRET{value}
\end{pseudo}

Note that when $\ABitsLeft==0$, all subsequent values read by $read\_sintb()$ will be 0.
