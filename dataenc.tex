%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how raw and VLC data  - %
% - is extracted                               - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Data is encoded in the Dirac bitstream in four basic ways: fixed-length
bit-wise and byte-wise encodings; variable-length codes; and arithmetic encoding.

This section defines how data bits are extracted from the bitstream and how
sequences of bits are interpreted as values of various types using fundamental
data-reading functions, covering encodings of the first two sorts. The extraction
of arithmetic-encoded data is defined in Section \ref{arithdecoding}.

\subsection{Bit-packing and data input}
\label{bitpacking}

This section defines the operation of the $read\_bit()$, $read\_byte()$ 
and $byte\_align()$ functions used for direct access to the Dirac stream.

Access to the Dirac stream is bytewise, and a decoder is deemed to maintain
a copy of the current byte, $\CurrentByte$, and an index to the next bit
to be read, $\NextBit$. $\NextBit$ is an integer from 0 (least-significant bit) to 7 
(most-significant bit). Bits within bytes are accessed from the msb first to the
lsb.

Each access unit and individual picture is a whole number of bytes. Decoding from the
start of an access unit, $\NextBit$ is set to 7.

The $read\_byte()$ function performs the following steps --
\begin{enumerate}
\item Sets $\NextBit=7$ 
\item Sets $\CurrentByte$ to the next unread byte in the Dirac stream
\end{enumerate}

The $read\_bit()$ function is defined by

\begin{pseudo}{read\_bit}{}
\bsIF{\NextBit == 7}
\bsCODE{read\_byte()}
\bsEND
\bsCODE{bit = ( \CurrentByte \gg \NextBit ) \& 1 }
\bsCODE{\NextBit -= 1}
\bsIF{\NextBit<0}
    \bsCODE{\NextBit == 7}
\bsEND
\bsRET{bit}
\end{pseudo}

The $byte\_align()$ function discards data in the current byte and begins data access
at the next byte, unless input is already at the beginning of a byte: 

\begin{pseudo}{byte\_align}{}
\bsCODE{\NextBit = 7}
\end{pseudo}

This is used to ensure that a whole number of bytes are read before
beginning reading a new stream element.

\subsection{Fixed-length code formats}
\subsubsection{Bool}

The $read\_bool()$ function returns --
\begin{itemize}
\item $\true$ if $read\_bit()$ is $1$
\item $\false$ if $read\_bit()$ is $0$
\end{itemize}

\subsubsection{n-bit literal}
An $n$-bit number in literal format shall be decoded by extracting $n$ bits
in order, using the $read\_bit()$ function (Section \ref{bitpacking})
 and placing the first bit in the leftmost position, the second
bit in the next position and so on. The resulting value is to be
interpreted as an unsigned integer:

\begin{pseudo}{read\_nbits}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_bit()}
    \bsCODE{val \ll = 1}
\bsEND
\bsRET{val}
\end{pseudo}

\begin{informative}
Note that the result of $read\_nbits(8)$ is different from the result of $read\_byte()$,
since individual bits are read from MSB to LSB rather than the other way round.
\end{informative}

\subsubsection{$n$-byte unsigned integer literal}
A single byte may be interpreted as an unsigned integer value from 0 to 255.

An $n$-byte number in literal format shall be decoded by the recipe:

\begin{pseudo}{read\_uint\_lit}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_byte()}{\ref{bitpacking}}
    \bsCODE{val \ll = 8}
\bsEND
\bsRET{val}
\end{pseudo}

\subsection{Variable-length code formats}
\label{vlc}
Variable-length codes are used in two ways in the Dirac stream. The first
use is for direct encoding into the stream. The second use is for binarisation
in the arithmetic encoding/decoding process so that integer values may be 
coded and decoded using a binary arithmetic coding engine. 

\subsubsection{Unsigned interleaved exp-Golomb}
This section defines the unsigned interleaved exp-Golomb data format and the operation
of the $read\_uint()$ function. 

Unsigned interleaved exp-Golomb data is decoded to produce unsigned
 integer values.The format consists of two interleaved parts, 
and each code is an odd number, $2K+1$ bits in length.

The $K+1$ bits in the even positions (counting from zero) are the ``follow" bits, and 
the $K$ bits in the odd positions are the ``data" bits $b_i$ which are used to construct
the decoded value itself. A follow bit value of $0$ indicates a subsequent data bit,
whereas a follow bit value of $1$ terminates the code:
\begin{equation*}
0\quad b_{K-1}\quad 0\quad b_{K-2}\hdots 0\quad b_{0}\quad 1
\end{equation*}

The data bits $b_{K-1}, b_{K-2}, \hdots, b_0$ are the binary representation 
 of the first $K$ bits of the $(K+1)$-bit number 
$N+1$, where $N$ is the number to be decoded:
\begin{equation*}
N+1=1 b_{K-1} b_{K-2}\hdots b_0 \text{(base $2$)}
\end{equation*}

A table of encodings of the first 10 values is shown in Figure \ref{uegolcodings}.

\begin{figure}[h]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
1                 &  0\\
0 0 1             &  1\\
0 1 1             &  2\\
0 0 0 0 1         &  3\\
0 0 0 1 1         &  4\\
0 1 0 0 1         &  5\\
0 1 0 1 1         &  6\\
0 0 0 0 0 0 1     &  7\\
0 0 0 0 0 1 1     &  8\\
0 0 0 1 0 0 1     &  9\\
\end{tabular}

\caption{Example conversions from unsigned interleaved exp-Golomb-coded 
values to unsigned integers \label{uegolcodings}}
\end{figure}

Although apparently complex, the interleaving ensures that the code has a very simple decoding loop. 
The $read\_uint()$ function returns an unsigned integer value and is defined by the recipe:

\begin{pseudo}{read\_uint}{}
\bsCODE{value = 1}
\bsWHILE{read\_bool()== \false}
  \bsCODE{value \ll = 1}
  \bsIF{read\_bool()==\true}
    \bsCODE{value += 1}
  \bsEND
\bsEND
\bsCODE{value -= 1}
\bsRET{value}

\end{pseudo}


\begin{informative}
Conventional exp-Golomb coding places all follow bits at the beginning as a prefix. This is
easier to read, but requires that a count of the prefix length be maintained. Values can only
be decoded in two loops -- the prefix followed by the data bits. Interleaved exp-Golomb 
coding allows values to be decoded in a single loop, without the need for a length count.
\end{informative}

\subsubsection{Signed interleaved exp-Golomb}
\label{segol}

This section defines the signed interleaved exp-Golomb data format and the operation
of the $read\_sint()$ function.

The code for the signed interleaved exp-Golomb data format consists of the
unsigned interleaved exp-Golomb code for the magnitude, followed by a sign bit
for non-zero values (Figure \ref{segolcodings}).

\begin{figure}[h]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
1                 &  0\\
0 0 1 1           &  -1\\
0 0 1 0           &  1\\
0 1 1 1            &  -2\\
0 1 1 0            &  2\\
0 0 0 0 1 1         &  -3\\
0 0 0 0 1 0         &  3\\
0 0 0 1 1 1         &  -4\\
0 0 0 1 1 0         &  4\\
\end{tabular}

\caption{Example conversions from signed interleaved exp-Golomb-coded values 
to signed integers \label{segolcodings}}
\end{figure}

The decoding operation is as follows.

\begin{pseudo}{read\_sint}{}
\bsCODE{value = read\_uint()}
\bsIF{read\_bool()==\true}
  \bsCODE{value = -value}
\bsEND
\bsRET{value}

\end{pseudo}
