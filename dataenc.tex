%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% - This chapter defines how raw and VLC data  - %
% - is extracted                               - % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Data is encoded in the Dirac bitstream in four basic ways: fixed-length
bit-wise and byte-wise encodings; variable-length codes; and arithmetic encoding.

This section defines how data bits are extracted from the bitstream and how
sequences of bits are interpreted as values of various types using fundamental
data-reading functions. The extraction of arithmetic-encoded data makes use of
an arithmetic decoding engine which is specified in Appendix \ref{arithengine}.

\subsection{Bit-packing and data input}
\label{bitpacking}

This section defines the operation of the $read\_bit()$, $read\_byte()$ 
and $byte\_align()$ functions used for direct access to the Dirac stream.

Access to the Dirac stream is bytewise, and a decoder is deemed to maintain
a copy of the current byte, $\CurrentByte$, and an index to the next bit
to be read, $\NextBit$. $\NextBit$ is an integer from 0 (least-significant bit) to 7 
(most-significant bit). Bits within bytes are accessed from the msb first to the
lsb.

Each access unit and individual picture is a whole number of bytes. Decoding from the
start of an access unit, $\NextBit$ is set to 7.

The $read\_byte()$ function performs the following steps --
\begin{enumerate}
\item Sets $\NextBit=7$ 
\item Sets $\CurrentByte$ to the next unread byte in the Dirac stream
\end{enumerate}

The $read\_bit()$ function is defined by

\begin{pseudo}{read\_bit}{}
\bsCODE{bit = ( \CurrentByte \gg \NextBit ) \& 1 }
\bsCODE{\NextBit -= 1}
\bsIF{\NextBit<0}
    \bsCODE{\NextBit = 7}
    \bsCODE{read\_byte()}
\bsEND
\bsRET{bit}
\end{pseudo}

The $byte\_align()$ function discards data in the current byte and begins data access
at the next byte, unless input is already at the beginning of a byte: 

\begin{pseudo}{byte\_align}{}
\bsIF{\NextBit != 7}
    \bsCODE{read\_byte()}
\bsEND
\end{pseudo}

This is used to ensure that a whole number of bytes are read before
beginning reading a new stream element.

\subsection{Parsing of fixed-length data}
\subsubsection{Bool}

The $read\_bool()$ function identifies 1 with $\true$ and 0 with $\false$:

\begin{pseudo}{read\_bool}{}
\bsIF{read\_bit()==1}
    \bsRET{\true}
\bsELSE
    \bsRET{\false}
\bsEND
\end{pseudo}

\subsubsection{n-bit literal}
An $n$-bit number in literal format shall be decoded by extracting $n$ bits
in order, using the $read\_bit()$ function (Section \ref{bitpacking})
 and placing the first bit in the leftmost position, the second
bit in the next position and so on. The resulting value is to be
interpreted as an unsigned integer:

\begin{pseudo}{read\_nbits}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_bit()}
    \bsCODE{val \ll = 1}
\bsEND
\bsRET{val}
\end{pseudo}

\subsubsection{$n$-byte unsigned integer literal}
A single byte may be interpreted as an unsigned integer value from 0 to 255.

An $n$-byte number in literal format shall be decoded by the recipe:

\begin{pseudo}{read\_uint\_lit}{n}
\bsCODE{val=0}
\bsFOR{i=0}{n-1}
    \bsCODE{val += read\_byte()}{\ref{bitpacking}}
    \bsCODE{val \ll = 8}
\bsEND
\bsRET{val}
\end{pseudo}

\subsection{Parsing of VLC coded data}
\label{vlc}
Variable-length codes are used in three ways in the Dirac stream. The first
use is for direct encoding of header values into the stream. The second use
is for entropy coding of motion data and coefficients, where arithmetic decoding
is not in use.

The third use 
is for binarisation in the arithmetic encoding/decoding process so that integer 
values may be coded and decoded using a binary arithmetic coding engine. This is
described in Section \ref{arithdecoding}.

When used for coding motion data and coefficients, VLCs are employed within
a data block of known length. It is possible to gain additional compression by early termination:
maintaining a count of remaining bits, and returning default values when this length
is exceeded. This is achieved by use of the $read\_bitb()$, $read\_boolb()$, 
$read\_uintb()$ and $read\_sintb()$ for reading values from data blocks. 
(A similar early termination facility is a used for arithmetic decoding.)

\subsubsection{Data input for bounded block operation}
\label{blockreadbit}

This section specifies the operation of the $read\_bitb()$ process for reading bits from
a block of known size. In this case, the decoder state variable $\ABitsLeft$ has been
set to the block length, and is decremented on reading a bit. When all bits in the block
have been read, then $1$ is returned by default:

\begin{pseudo}{read\_bitb}{}
\bsIF{\ABitsLeft==0}
  \bsRET{1}
\bsELSE
  \bsCODE{\ABitsLeft -= 1}
  \bsRET{read\_bit()}
\bsEND
\end{pseudo}

It is possible that not all data in a block is exhausted after a sequence of read operations.
At the end of a sequence of read operations, the decoder will flush the block. This assists
with recovery in the event of errors in the stream, and enforces byte-alignment where required 
(for example in arithmetic coded blocks).

\begin{pseudo}{flush\_inputb}{}
\bsWHILE{\ABitsLeft>0}
    \bsCODE{read\_bit()}
    \bsCODE{\ABitsLeft-=1}
\bsEND
\end{pseudo}


\subsubsection{Unsigned interleaved exp-Golomb codes}
This section defines the unsigned interleaved exp-Golomb data format and the operation
of the $read\_uint()$ and the $read\_uintb()$ functions. 

Unsigned interleaved exp-Golomb data is decoded to produce unsigned
 integer values.The format consists of two interleaved parts, 
and each code is an odd number, $2K+1$ bits in length.

The $K+1$ bits in the even positions (counting from zero) are the ``follow" bits, and 
the $K$ bits in the odd positions are the ``data" bits $b_i$ which are used to construct
the decoded value itself. A follow bit value of $0$ indicates a subsequent data bit,
whereas a follow bit value of $1$ terminates the code:
\begin{equation*}
0\quad b_{K-1}\quad 0\quad b_{K-2}\hdots 0\quad b_{0}\quad 1
\end{equation*}

The data bits $b_{K-1}, b_{K-2}, \hdots, b_0$ are the binary representation 
 of the first $K$ bits of the $(K+1)$-bit number 
$N+1$, where $N$ is the number to be decoded:
\begin{equation*}
N+1=1 b_{K-1} b_{K-2}\hdots b_0 \text{(base $2$)}
\end{equation*}

A table of encodings of the first 10 values is shown in Figure \ref{uegolcodings}.

\begin{figure}[!ht]]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
1                 &  0\\
0 0 1             &  1\\
0 1 1             &  2\\
0 0 0 0 1         &  3\\
0 0 0 1 1         &  4\\
0 1 0 0 1         &  5\\
0 1 0 1 1         &  6\\
0 0 0 0 0 0 1     &  7\\
0 0 0 0 0 1 1     &  8\\
0 0 0 1 0 0 1     &  9\\
\end{tabular}

\caption{Example conversions from unsigned interleaved exp-Golomb-coded 
values to unsigned integers \label{uegolcodings}}
\end{figure}

Although apparently complex, the interleaving ensures that the code has a very simple decoding loop. 
The $read\_uint()$ function returns an unsigned integer value and is defined by the recipe:

\begin{pseudo}{read\_uint}{}
\bsCODE{value = 1}
\bsWHILE{read\_bit() == 0}
  \bsCODE{value \ll = 1}
  \bsIF{read\_bit()==1}
    \bsCODE{value += 1}
  \bsEND
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

\begin{informative}
Conventional exp-Golomb coding places all follow bits at the beginning as a prefix. This is
easier to read, but requires that a count of the prefix length be maintained. Values can only
be decoded in two loops -- the prefix followed by the data bits. Interleaved exp-Golomb 
coding allows values to be decoded in a single loop, without the need for a length count.
\end{informative}

The $read\_uintb()$ function is identical to $read\_uint()$ except that the block-bounded read
operation is employed:

\begin{pseudo}{read\_uintb}{}
\bsCODE{value = 1}
\bsWHILE{read\_bitb() == 0}
  \bsCODE{value \ll = 1}
  \bsIF{read\_bitb()==\true}
    \bsCODE{value += 1}
  \bsEND
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

Note that when $\ABitsLeft==0$, all subsequent values read by $read\_uintb()$ will be 0.

\subsubsection{Signed interleaved exp-Golomb}
\label{segol}

This section defines the signed interleaved exp-Golomb data format and the operation
of the $read\_sint()$ and $read\_sintb()$ functions.

The code for the signed interleaved exp-Golomb data format consists of the
unsigned interleaved exp-Golomb code for the magnitude, followed by a sign bit
for non-zero values (Figure \ref{segolcodings}).

\begin{figure}[!ht]
\centering
\begin{tabular}{l|c}
Bit sequence & Decoded value \\
\hline\\
0 0 0 1 1 1         &  -4\\
0 0 0 0 1 1         &  -3\\
0 1 1 1            &  -2\\
0 0 1 1           &  -1\\
1                 &  0\\
0 0 1 0           &  1\\
0 1 1 0            &  2\\
0 0 0 0 1 0         &  3\\
0 0 0 1 1 0         &  4\\
\end{tabular}

\caption{Example conversions from signed interleaved exp-Golomb-coded values 
to signed integers \label{segolcodings}}
\end{figure}

The decoding operation is as follows.

\begin{pseudo}{read\_sint}{}
\bsCODE{value = read\_uint()}
\bsIF{ value!= 0}
  \bsIF{read\_bit()==1}
    \bsCODE{value = -value}
  \bsEND
\bsEND
\bsRET{value}
\end{pseudo}

The $read\_sintb()$ function is identical to $read\_sint()$ except that the block-bounded read
operation is employed:

\begin{pseudo}{read\_sintb}{}
\bsCODE{value = read\_uintb()}
\bsIF{value != 0}
  \bsIF{read\_bitb()==1}
    \bsCODE{value = -value}
  \bsEND
\bsEND
\bsRET{value}
\end{pseudo}

Note that when $\ABitsLeft==0$, all subsequent values read by $read\_sintb()$ will be 0.

\subsection{Parsing of arithmetic-coded data}

\label{arithdecoding}

This section defines the operations for reading and writing arithmetic-coded
data, and may be thought of as specifying an API for
extracting data elements using the arithmetic decoding engine, making use
of elementary arithmetic coding functions defined by the arithmetic decoding engine 
specified in Appendix \ref{arithengine}.

Arithmetically-coded data is present in the Dirac stream in data blocks which consist of
a whole number of bytes and are byte aligned. Where arithmetic coding is used, each such
block is preceded by data which includes a length code $length$, which is equal to the length in
bytes of the data block. The function $initialise\_arithmetic\_decoding(length)$
(Section \ref{initarith}) then initialises the arithmetic decoder. Once the arithmetic
decoder is initialised, boolean and integer values may be extracted.

After all values in a particular arithmetic coded block have been parsed, and remaining data
is purged by calling $flush\_inputb()$ (Section \ref{blockreadbit}).



\subsubsection{Contexts}

Values are extracted by using binary {\em contexts}, which are estimates of the 
probability of the binary values extracted being 0 ($\false$) or 1 ($\true$).
Contexts are determined prior to values being extracted, based on previously
decoded data, and are updated by the arithmetic decoding engine to track 
statistics. The structure of contexts and how they are initialised and updated 
is specified in Section \ref{arithcontexts}.

The set of contexts is $\AContexts$, and an individual context is accessed via
an index $\AContexts[i]$. 

\paragraph{Context indices}
\label{contextindices}
$\ $\newline
The following context indices are used within the Dirac decoder:

Wavelet coefficient contexts:

\SignZero\\
\SignPos\\
\SignNeg\\
\ZPZNFollowOne\\
\ZPNNFollowOne\\
\ZPFollowTwo\\
\ZPFollowThree\\
\ZPFollowFour\\
\ZPFollowFive\\
\ZPFollowSixPlus\\
\NPZNFollowOne\\
\NPNNFollowOne\\
\NPFollowTwo\\
\NPFollowThree\\
\NPFollowFour\\
\NPFollowFive\\
\NPFollowSixPlus\\
\CoeffData\\
\ZeroCodeblock\\
\QOffsetFollow\\
\QOffsetData\\
\QOffsetSign\\

Motion data contexts:

\SBSplitFollowOne\\
\SBSplitFollowTwo\\
\SBSplitData\\
\PredModeOne\\
\PredModeTwo\\
\BlockGlobal\\
\VectorFollowOne\\
\VectorFollowTwo\\
\VectorFollowThree\\
\VectorFollowFour\\
\VectorFollowFivePlus\\
\VectorData\\
\VectorSign\\
\DCFollowOne\\
\DCFollowTwoPlus\\
\DCData\\
\DCSign\\

\subsubsection{Arithmetic decoding of boolean values}

Given a context index $i$, the arithmetic decoding engine supports a function
$read\_boola(i)$, specified in Section \ref{arithreadbool}, which returns the 
boolean value $\true$ or $\false$.

\subsubsection{Arithmetic decoding of integer values}

\label{arithreadint}

This section defines the operation of the $read\_sinta(context\_set)$ and
$read\_uinta(context\_set)$ function
 for extracting integer values from a block of arithmetically coded data.

\paragraph{Binarisation and contexts}
$\ $\newline
Signed and unsigned integer values are binarised using interleaved exp-Golomb
 binarisation as per Section \ref{vlc}: the $read\_sinta()$ and $read\_uinta()$
processes are essentially identical to the 
$read\_sint()$ and $read\_uint()$ processes, except that instances of $read\_bool()$ are replaced
by instances of $read\_boola()$ (Section \ref{arithreadbool}) using suitable contextualisation. 

A choice of context depends upon whether the bit is a data bit, follow bit, 
or sign bit, and upon the position of the bit within the binarisation: 
$context\_set$ consists of three parts -
\begin{itemize}
\item an array of follow context indices, $context\_set[follow]$ (indexed from 0 to 
$\length(context\_set[follow])-1$)
\item a single data context index, $context\_set[data]$ 
\item a sign context index, $context\_set[sign]$ (ignored for unsigned integer decoding)
\end{itemize}

Each follow context is used for decoding the corresponding follow bit, with the
last follow context being used for all subsequent follow bits (if any) also. 
The follow context selection function $follow\_context()$ is defined by:

\begin{pseudo}{follow\_context}{index, context\_set}
\bsCODE{pos= \min(index, length(context\_set[follow])-1 }
\bsCODE{ctx\_index = context\_set[follow][pos]}
\bsRET{\AContexts[ctx\_index]}
\end{pseudo}

So the last follow context is used for all the remaining follow bits also.

\paragraph{Unsigned integer decoding}
$\ $\newline
Unsigned integers are decoded by:

\begin{pseudo}{read\_uinta}{context\_set}
\bsCODE{value = 1}
\bsCODE{index = 0}
\bsWHILE{read\_boola(follow\_context(index,context\_set) )== \false}
  \bsCODE{value \ll = 1}
  \bsIF{read\_boola(\text{state[contexts]}[context\_set[data])])}
    \bsCODE{value += 1}
  \bsEND
  \bsCODE{index += 1}
\bsEND
\bsCODE{value -= 1}
\bsRET{value}
\end{pseudo}

\paragraph{Signed integer decoding}
$\ $\newline
$read\_sinta()$ decodes first the magnitude then the sign, as necessary:

\begin{pseudo}{read\_sinta}{context\_set}
\bsCODE{value=read\_uinta(context\_set)}
\bsIF{value != 0}
  \bsIF{read\_boola(\AContexts[context\_set[sign])]) == \true}
    \bsCODE{value=-value}
  \bsEND
\bsEND
\bsRET{value}
\end{pseudo}