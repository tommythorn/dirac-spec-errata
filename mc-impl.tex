
\begin{informative}
The motion compensation process is defined in this specification in
terms of the prediction determined for each pixel. Typically, an
implementation will motion compensate all pixels within a prediction
unit or a block together, as they share motion parameters and hence will
have a contiguous prediction data set in the reference frames.


The weighting matrix is then applied directly
to the prediction block as a whole.

It is not necessary for the prediction buffer to consist of the whole video
component -- it could be a single row of blocks, with values being overwritten
successively.
\end{informative}

\begin{comment}
The process for a single video component is effectively:

-- Starting with an empty prediction buffer,
pred(x,y) = 0, forall x,y

for r = 0 to numrefs:
    -- upconvert the reference frame and clip the results
    ref'_r(x,y) = clip(upconvert(ref_r,x,y),0,2^{video_depth})

    -- perform block prediction, OBMC weighting and reference weighting,
    -- accumumulating the results into the prediction buffer.
    foreach b in blocks:
        b'pred(x,y) = block_predict(b,x,y)

        -- choosereference weight contribution
        W <- ...

        for i = 0 to yblen:
            for j = 0 to xblen:
                -- accumulate predicted pixels into prediction buffer
                pred

%\begin{lstlisting}
%    upconvertB_1d(f,r,x) = let $x' = x mod f$
%                           in $%
%    \lfloor\frac{(16-fx')r_{\frac{x-x'}{f}} + fx'r_{\frac{x+f-x'}{f}} + 8}{16}\rfloor%
%    $
%\end{lstlisting}
\end{comment}

\annotate{df}{Contrasts to the rest of the
section that uses absolute pixel position (not vector)}
\begin{informative}
A note about global motion calculation.

It is possible to calculate the entire global motion field using
approximately four additions per pixel.

The global transformation may be expanded as:

\begin{equation*}
\pmb{z}_{ref} = -\pmb{A}\left(\pmb{z}\pmb{z}^\text{T}\right)\pmb{c}
                + \left(\pmb{A} - \pmb{b}\pmb{c}^\text{T}\right)\pmb{z}
                + \pmb{b}
\end{equation*}

Then $\pmb{z}_{ref} - \pmb{z}$ may be further expanded to give the individual
components of the motion vector:

\begin{align*}
  v_x &= \alpha{}x^2 + \beta{}xy + \gamma{}y^2 + (\delta - 1)x + \epsilon{}y + b_1 \\
  v_y &= \zeta{}x^2 + \eta{}xy + \theta{}y^2 + \kappa{}x + (\mu - 1)y + b_2 \\
\end{align*}
where,
\begin{align*}
\alpha &= -a_{11}c_1 &
\beta &= -(a_{11}c_2 + a_{12}c_1) &
\gamma &= -a_{12}c_2 \\
\delta &= a_{11} - b_1c_1 &
\epsilon &= a_{12} - b_1c_2 &
\zeta &= -a_{21}c_1 \\
\eta &= -(a_{21}c_2 + a_{22}c_1) &
\theta &= -a_{22}c_2 &
\kappa &= a_{21} - b_2c_1 &
\mu &= a_{22} - b_2c_2
\end{align*}

That is the components of the global motion vector are given by
two-dimensional quadratic functions.

Given a two dimensional quadratic function:

\begin{equation*}
z(x,y) = px^2 + qxy + ry^2 + sx + ty + u
\end{equation*}

We can calculate z(y,x) for successive values of $x$ and $y$ by merely
incremeting the values for $z(y, x-1)$ or $z(y-1, x)$.  The following
algorithm for generating a two dimensional array containing the quadratic
values $z(y,x)$.

\begin{verbatim}
quadratic(p,q,r,s,t,u):
    zed = array2D(ylength, xlength)
    g = 2*p
    h0 = s - p - q
    k = 2*r
    m0 = t - r
    m = m0 - k
    z0 = u - m0
    for y in range(ylength):
        h0 += q
        h = h0 - g
        m += k
        z0 += m
        z = z0 - h0
        for x in range(xlength):
            h += g
            z += h
            zed[y][x] = z
    return zed
\end{verbatim}

\end{informative}
