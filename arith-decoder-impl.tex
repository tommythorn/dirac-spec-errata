
%src: tim-0.9.1.48

\begin{informative}

Arithmetic decoding is specified in terms of fixed point arithmetic.
Word widths are defined in the table below.

\begin{tabular}{l|c}
Variable & Width (bits)\\
\hline
bits\_left & 3\\
bit\_buffer & 8\\
low & 16\\
high & 16\\
code & 16\\
context[0] & 8\\
context[1] & 8\\
weight & 8\\
scaler & 16\\
probability0 & 16\\
count & 17 (See informative text for 16 bit systems)\\
range & 17 (See informative text for 16 bit systems)\\
range\_x\_prob & 16
\end{tabular}

probability0 is an estimate of the probability of 0 (Boolean False)
occurring. It is scaled by $2^{16}$ so that probability 0 is represented by
0 and probability 1 is represented by 65536.  In this implementation of
arithmetic coding the probabilities can never take the values 0 or 1
(because contexts are initialised so that count0=count1=1), Ideally the
probability estimate would be calculated from the ratio of the counts of
previous zeros and ones, i.e.:

\begin{displaymath}
probability of zero \approx \frac{count0}{count0 + count1}
\end{displaymath}

Implementing this would require a division per decoded bit, which is
computationally expensive. Instead we multiply by the inverse of
(count0+count1), i.e. we multiply by 1/weight (suitably scaled for fixed
point arithmetic). The integer division can be pre-calculated as a
lookup table. So one possible implementation for calculating
probability0 might be:


Possible implementation for calculating "probability0"
\begin{verbatim}
#Pre-calculate the lookup table
#Create an empty list with 256 elements

scaler = [None]*256

for weight in range(2,255):

    scaler[index] = (0x10000+weight//2)//weight
.
.
.
.
probability0 = context[0]*scaler[weight])
\end{verbatim}

Note: scaler is a lookup table with 256 entries each 16 bits wide. The
minimum weight is 2 (because of context initialisation) and the maximum
weight is 255 (beyond which the counts are halved). Hence entries for
weight 0 and 1 are undefined.

In the specification of "read\_ba(context)" first bits are read in to the
variable "code" until the MSB of "high" is 1 and the MSB of "low" is 0.
For efficiency, because high is always > low,  the test:

\begin{verbatim}
if (((high\&0x8000)==0x0) and ((low\&0x8000)==0x0)):
\end{verbatim}

may be replaced by:

\begin{verbatim}
if ( (high\^low)<0x8000 ):
\end{verbatim}

After  sufficient bits have been read in the 2nd MSB (bit 14) is
sometimes deleted, but the mechanism is not obvious. The way this works
is as follows:

The 2nd MSB should be deleted when the current range, defined by high
and low, straddles the halfway point, a condition known as underflow.
Under these circumstances the values of code, high and low are (with a
and b being specific Boolean values, $\bar{a}$ being not a and x being any
value):

\begin{verbatim}
code    =       a$\bar{a}$xxxxxxxxxxxxxx
high    =       10xxxxxxxxxxxxxx
low     =       01xxxxxxxxxxxxxx
In the specification the 2nd MSBs are inverted yielding:
code    =       aaxxxxxxxxxxxxxx
high    =       11xxxxxxxxxxxxxx
low     =       00xxxxxxxxxxxxxx
This makes the 2nd MSB the same as the MSB. The MSB is now discarded by
shifting bits left giving:
code    =       axxxxxxxxxxxxxxb
high    =       1xxxxxxxxxxxxxx1
low     =       0xxxxxxxxxxxxxx0
The overall effect is to delete the 2nd MSB.
\end{verbatim}

The word widths for variables count and range are specified as 17
bits. This may be inefficient in 16 bit implementations. The 17th bit is
only required in the special case when "code"/"high" equals 0xFFFF and
"low" equals 0. The algorithm may be refactored as follows so that 16
bit arithmetic may be used without overflow:


Read Binary Arithmetic Coded Bit (alternative 16 bit version)
\begin{verbatim}
read_ba(context):
    .
    .
    .
    count = code - low
    range = high - low
    range_x_prob = (range*probability0 + probability0)>>16
    if ( count > (range_x_prob-1) ):
    .
    .
    .
\end{verbatim}

The function "read\_ba(context)" has not been specified in this way for
clarity. Although this alternative would work for word widths of 16 bits
or more, to specify it this way would obfuscate the algorithm.

\end{informative}
