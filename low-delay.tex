\label{lowdelayparsing}

This section specifies the $low\_delay\_picture()$ process for unpacking 
wavelet coefficients in the low-delay syntax.

In low-delay operation, the Dirac syntax partitions the wavelet coefficients into a number of sets,
from all subbands, corresponding to a localised area of the picture (Figure \ref{fig:waveletslice}).
Note that it is the coefficients that are divided,
not the picture. These sets are called slices. A single quantiser, weighted by a quantisation matrix, is used for each slice, 
a slice is  of fixed dimensions within a picture and is also of fixed length in bytes. Each slice interleaves all three components, and hence
the transform parameters for the components are placed in the picture header.

In the low-delay syntax, all wavelet coefficients are entropy-coded using variable-length
codes, not arithmetic coding.

\begin{figure}[!ht]
\centering
%\includegraphics[width=0.7\textwidth]{figs/wavelet-slice.eps}
\caption{Partition of wavelet coefficients into slices}
\label{fig:waveletslice}
\end{figure}

This section specifies the syntax and coefficient unpacking operations only: picture decoding operations are as specified in Section \ref{picturedec}. However, the slice
structure implies that in practice incremental picture decoding can be easily achieved without
accumulating an entire picture data set (wavelet coefficients and motion vectors), yielding a decoding delay
proportional to the height of the slices. (The actual achievable delay may be more than one slice height because
of the extended support of wavelet filters and motion block overlaps.)

\begin{informative}
Not allowing slice bit allocations to vary within a picture does impact on
compression efficiency, but on the other hand vastly simplifies both encoder and decoder hardware. Furthermore, by
not allowing load-balancing within a buffer, it assists a chain of multiple encoders and decoders using the same
slice parameters in producing identical coding decisions and hence no cascading loss. These are all factors of great 
significance in a professional environment.
\end{informative}

Although this specification is not concerned with network adaption and carriage over data interfaces, low-delay
applications may have specific requirements for headerless and synchronous operation which may imply that
data carried ``on the wire" should differ from a straight-forward encapsulation of the stream. How this should
be done in particular cases is described in Section \ref{apps}.

\subsubsection{Overall process}
\label{ldpicture}

In the low-delay syntax, each picture is merely a concatenation of slices. 
The number of slices in a picture is determined from the padded picture dimensions
-- the padding being that required for the application of the wavelet transform to depth $\WaveletDepth$.

\begin{pseudo}{low\_delay\_transform\_data()}{}
\bsCODE{\YTransform = initialise\_wavelet\_data(Y)}{\ref{wltinit}}
\bsCODE{\COneTransform = initialise\_wavelet\_data(C1)}{\ref{wltinit}}
\bsCODE{\CTwoTransform = initialise\_wavelet\_data(C2)}{\ref{wltinit}}
\bsCODE{ph=2^{\TransformDepth}*\left\lceil\frac{\LumaHeight}{2^{\TransformDepth}}\right\rceil}
\bsCODE{pw= 2^{\TransformDepth}*\left\lceil\frac{\LumaWidth}{2^{\TransformDepth}}\right\rceil}
\bsCODE{\SlicesX=pw//\SliceWidth}
\bsCODE{\SlicesY=ph//\SliceHeight}
\bsFOR{sy=0}{\SlicesY-1}
  \bsFOR{sx=0}{\SlicesX-1}
    \bsCODE{slice(sy, sx)}{\ref{sliceparsing}}
  \bsEND
\bsEND
\bsIF{is\_intra()}
    \bsCODE{intra\_dc\_prediction(\YTransform[0][\LL])}{\ref{intradcprediction}}
    \bsCODE{intra\_dc\_prediction(\COneTransform[0][\LL])}{\ref{intradcprediction}}
    \bsCODE{intra\_dc\_prediction(\CTwoTransform[0][\LL])}{\ref{intradcprediction}}
\bsEND
\end{pseudo}

Note that the padded dimensions are the padded luma dimensions. Since these are divisible 
by $2^\TransformDepth$ they are {\em a fortiori} divisible by the slice dimensions by 
the constraints of Section \ref{sliceparams}. 

Note also that intra DC coefficient prediction
occurs across all the wavelet coefficients, and in particular DC values on the edge of a slice
are predicted from DC values in previously unpacked slices, which must be cached. 

\subsubsection{Slices}
\label{sliceparsing}

This section specifies the operation of the $slice(sy,sx)$ process for unpacking coefficients
within the slice with coordinates $(sx,sy)$. Each slice
contains coefficients from all subbands and components. Luma data is unpacked first, followed by the chroma data, which
is interleaved. A length code allows the luma and chroma coefficients each to be terminated early, with remaining values
set to zero.

The overall slice unpacking process is as follows:

\begin{pseudo}{slice}{sy,sx}
\bsCODE{slice\_bits\_left = 8*slice\_bytes(sy,sx)}{\ref{slicebytes}}
\bsCODE{qindex=read\_nbits(7)}
\bsCODE{slice\_bits\_left -= 7}
\bsCODE{slice\_quantisers(qindex)}{\ref{slicequantisers}}
\bsCODE{length\_bits = \log_2(8*slice\_bytes(sy,sx))}
\bsCODE{slice\_y\_length=read\_nbits(length\_bits)}
\bsCODE{slice\_bits\_left -= length\_bits}
\bsCODE{\ABitsLeft=slice\_y\_length}
\bsCODE{luma\_slice\_band(0,\LL,sy,sx,q_idx[0][\LL])}{\ref{lumasliceband}}
\bsFOR{level=1}{\WaveletDepth}
  \bsFOREACH{orient}{\HL,\LH,\HH}
    \bsCODE{luma\_slice\_band(level,orient,sy,sx)}{\ref{lumasliceband}}
  \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\bsCODE{slice\_bits\_left -= slice\_y\_length}
\bsCODE{\ABitsLeft=slice\_bits\_left}
\bsCODE{chroma\_slice\_band(0,\LL,sy,sx,q_idx)}{\ref{chromasliceband}}
\bsFOR{level=1}{\WaveletDepth}
  \bsFOREACH{orient}{\HL,\LH,\HH}
    \bsCODE{chroma\_slice\_band(level,orient,sy,sx)}{\ref{chromasliceband}}
  \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\subsubsection{Slice bytes}
\label{slicebytes}

This section specifies the $slice\_bytes(sy,sx)$ function for determining the number of bytes to be used for the slice at location $(sx,sy)$:

\begin{pseudo}{slice\_bytes}{sy,sx}
\bsCODE{slice\_num=sy*\SlicesX+sx}
\bsCODE{bytes = ((slice\_num+1)*\SliceBytesNum)//\SliceBytesDenom}
\bsCODE{bytes -= ((slice\_num)*\SliceBytesNum)//\SliceBytesDenom}
\bsRET{bytes}
\end{pseudo}

\subsubsection{Setting slice quantisers}
\label{slicequantisers}

This section specifies how quantisers for individual subbands are determined from the quantisation matrix
and the quantisation index.

\begin{pseudo}{set\_band\_quantisers}{qindex}
\bsCODE{slice\_comp\_quantisers(Y,qindex)}
\bsCODE{slice\_comp\_quantisers(C1,qindex)}
\bsCODE{slice\_comp\_quantisers(C1,qindex)}
\end{pseudo}

\begin{pseudo}{slice\_comp\_quantisers}{c,qindex}
\bsCODE{\Quant[c][0][\LL]=\max(qindex-\QuantMatrix[c][0][\LL],0)}
\bsFOR{level=1}{\WaveletDepth}
    \bsFOREACH{orient}{HL, LH, HH}
        \bsCODE{qval=\max(qindex-\QuantMatrix[c][level][orient],0)}
        \bsCODE{\Quant[c][level][orient]=qval}
    \bsEND
\bsEND
\end{pseudo}

$C1$ and $C2$ quantiser index offsets are determined from the video format defaults and the picture header
as per Appendix \ref{videoformatdefaults}.

\subsubsection{Slice subbands}
\label{sliceband}

This section specifies the operation of the $luma\_slice\_band( level,orient,sy,sx)$ for 
unpacking individual luma slice subbands, and $chroma\_slice\_band( level,orient,sy,sx)$. for 
unpacking individual chroma slice subbands.

\paragraph{Slice subband area}
$\ $\newline
The rectangular set of coefficients covered by a slice component ($Y$, $C1$ and $C2$) 
is demarcated by the values $left, right, top, bottom$, defined as fractions
of the subband dimensions (Section \ref{subbandwidthheight}):
\begin{eqnarray*}
  left & = & (subband\_width(level,c)*sx)//\SlicesX \\
  right & = & (subband\_width(level,c)*(sx+1))//\SlicesX \\
  bottom & = & (subband\_height(level,c)*sy)//\SlicesY \\
  top & = & (subband\_height(level,c)*(sy+1))//\SlicesY
\end{eqnarray*}

where $c=Y$ for luma coefficients, and $C1$ or $C2$ for chroma coefficients.

\paragraph{Luma slice subband data}
\label{lumasliceband}
$\ $\newline
\begin{pseudo}{luma\_slice\_band}{level, orient, sy, sx}
\bsFOR{y=bottom}{top-1}
  \bsFOR{x=left}{right-1}
    \bsITEM{val}{sintb}{\ref{segol}}
    \bsCODE{q=\Quant[Y][level][orient]}
    \bsCODE{\YTransform[level][orient]=inverse\_quant(val,q)}
  \bsEND
\bsEND
\end{pseudo}

\paragraph{Chroma slice subband data}
\label{chromasliceband}
$\ $\newline
\begin{pseudo}{luma\_slice\_band}{level, orinet, sy, sx}
\bsFOR{y=bottom}{top-1}
  \bsFOR{x=left}{right-1}
    \bsITEM{val}{sintb}{\ref{segol}}
    \bsCODE{q1=\Quant[C1][level][orient]}
    \bsCODE{q2=\Quant[C2][level][orient]}
    \bsCODE{\COneTransform[level][orient]=inverse\_quant(val,q1)}{\ref{invquant}}
    \bsITEM{val}{sintb}{\ref{segol}}
    \bsCODE{\CTwoTransform[level][orient]=inverse\_quant(val,q2)}{\ref{invquant}}
  \bsEND
\bsEND
\end{pseudo}

\begin{comment}
\begin{informative*}
\subsection{Data adaption and application requirements}
\label{apps}
\end{informative*}
\end{comment}