\section{Low-delay stream parsing}
\label{lowdelayparsing}

This section specifies the stream syntax to be used for low-delay profiles.
The overall format of the low-delay Dirac stream is as specified in Section \ref{streamstructure}. This section
specifies the picture data elements which are used in low-delay operation. 

In low-delay operation, the Dirac syntax partitions the wavelet coefficients into a number of sets,
from all subbands, corresponding to a localised area of the picture (Figure \ref{fig:waveletslice}).
 Note that it is the coefficients that are divided,
not the picture. These sets are called slices. A single quantiser, weighted by a quantisation matrix, is used for each slice, 
a slice is  of fixed dimensions within a picture and is also of fixed length in bytes. Each slice interleaves all three components, and hence
the transform parameters for the components are placed in the picture header.

In the low-delay syntax, all wavelet coefficients are entropy-coded using variable-length
codes, not arithmetic coding.

\begin{figure}[!ht]
\centering
%\includegraphics[width=0.7\textwidth]{figs/wavelet-slice.eps}
\caption{Partition of wavelet coefficients into slices}
\label{fig:waveletslice}
\end{figure}

This section specifies the syntax and parsing operations only: picture decoding operations are as
specified in Section \ref{picturedec}, \ref{idwt} and \ref{motioncompensate}. However, the slice
structure implies that in practice incremental picture decoding can be easily achieved without
accumulating an entire picture data set (wavelet coefficients and motion vectors), yielding a decoding delay
proportional to the height of the slices. (The actual achievable delay may be more than one slice height because
of the extended support of wavelet filters and motion block overlaps.)

\begin{informative}
Not allowing slice bit allocations to vary within a picture does impact on
compression efficiency, but on the other hand vastly simplifies both encoder and decoder hardware. Furthermore, by
not allowing load-balancing within a buffer, it assists a chain of multiple encoders and decoders using the same
slice parameters in producing identical coding decisions and hence no cascading loss. These are all factors of great 
significance in a professional environment.
\end{informative}

Although this specification is not concerned with network adaption and carriage over data interfaces, low-delay
applications may have specific requirements for headerless and synchronous operation which may imply that
data carried ``on the wire" should differ from a straight-forward encapsulation of the stream. How this should
be done in particular cases is described in Section \ref{apps}.

\subsection{Picture header elements}
\label{ldpictureheader}

This section specifies the operation of the $low\_delay\_header()$ process for parsing low-delay elements
of the picture header (Section \ref{pictureheader}).

The low delay elements consist of the wavelet transform parameters and the picture
prediction parameters (both placed in the picture header), the slice dimensions 
(width, height, byte allocation) and the quantisation matrix parameters:

\begin{pseudo}{low\_delay\_header}{}
    \bsCODE{transform\_parameters()}{\ref{transformparameters}}
    \bsCODE{picture\_prediction\_parameters()}{\ref{picpredparams}}
    \bsCODE{slice\_parameters()}{\ref{sliceparams}}
    \bsCODE{quant\_matrix()}{\ref{quantmatrix}}
\end{pseudo}

\subsubsection{Slice parameters and dimensions}
\label{sliceparams}

This section specifies the $slice\_parameters()$ process for parsing the width, height and bit allocation of 
the slices. Default slice dimensions are defined by the video format parameters in the AU header, as per Appendix 
\ref{videoformatdefaults}. They may be overridden as follows:

\begin{pseudo}{slice\_parameters}{}
\bsITEM{non\_default\_slice\_dims}{bool}
\bsIF{non\_default\_slice\_dims==\true}
    \bsITEM{width\_exp}{uint}
    \bsCODE{\SliceWidth=2^{width\_exp}}
    \bsITEM{height\_exp}{uint}
    \bsCODE{\SliceHeight=2^{height\_exp}}
\bsEND
\bsITEM{non\_default\_slice\_size}{bool}
\bsIF{non\_default\_slice\_size==\true}
    \bsITEM{\SliceBits}{uint}
\bsEND
\end{pseudo}

If $is\_low\_delay==\true$, the following constraints are placed upon the slice dimensions, the wavelet depth
 and motion compensation block sizes:

\begin{itemize}
\item $\SliceWidth$ and $\SliceHeight$ shall both be divisible by $2^\WaveletDepth$
\item If $is\_inter()==\true$, $\SliceWidth$ shall be divisible by $4*\LumaXBsep$ and $\SliceHeight$ shall be divisible by $4*\LumaYBsep$
\item Chroma and luma subbands must contain corresponding levels of padding, i.e. for all orientations $orient$ and levels $l$,
\begin{eqnarray*}
\width(\YTransform[l][orient]) & = & chroma\_h\_factor*\width(\COneTransform[l][orient]) \\
& = & chroma\_h\_factor*\width(\CTwoTransform[l][orient]) \\
\height(\YTransform[l][orient]) & = & chroma\_v\_factor*\height(\COneTransform[l][orient]) \\
& = & chroma\_v\_factor*\height(\CTwoTransform[l][orient]) \\
\end{eqnarray*}
\end{itemize}

These restrictions ensure that both wavelet coefficients and (if present) motion data superblocks may be partitioned
correctly by the slices. For example, the third condition restricts the transform depth to be at most 3 on $720\times 576$ 4:2:2 video
since a depth of 4 would lead to padding for chroma coefficients but not for luma, as $2^4=16$ divides 720 but not 360.

\subsubsection{Quantisation matrices}
\label{quantmatrix}

This section specifies the operation of the $quant\_matrix()$ process for setting the $\QuantMatrix$ parameters.

\begin{pseudo}{quant\_matrix}{}
\bsITEM{quant\_matrix\_index}{uint}
\bsIF{quant\_matrix\_index==0}
    \bsITEM{\QuantMatrix[0][\LL]}{uint}
    \bsFOR{level=1}{\WaveletDepth}
        \bsITEM{\QuantMatrix[level][\HL]}{uint}
        \bsITEM{\QuantMatrix[level][\LH]}{uint}
        \bsITEM{\QuantMatrix[level][\HH]}{uint}
    \bsEND
\bsELSE
    \bsCODE{set\_quant\_matrix(quant\_matrix\_index)}
\bsEND
\end{pseudo}

Default quantisation matrices are defined only if $\WaveletDepth$ is 4. If $\WaveletDepth!=4$ then $quant\_matrix\_index$ shall be 0 (custom).
The function $set\_quant\_matrix()$ sets the quantisation matrix based on the wavelet filter and the value of $quant\_matrix\_index$, as per Table
\ref{presetqmatrices}. For $quant\_matrix\_index==1$, this is an ``unweighted" matrix, whose values merely compensate for the differential 
power gain of the different subband filters. Higher values of $quant\_matrix\_index$ imply greater degrees of perceptual weighting.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|l|}
\hline
\WaveletIndex & quant\_matrix\_indices & {\bf Matrix values} \\
\hline
\end{tabular}
\caption{Preset quantisation matrices}\label{presetqmatrices}
\end{table}
  
\subsection{Low-delay picture parsing}
\label{ldpicture}

This section specifies the $low\_delay\_picture()$ process for parsing pictures in the low-delay syntax. Each picture
is merely a concatenation of slices. The number of slices in a picture is determined from the padded picture dimensions
-- the padding being that required for the application of the wavelet transform to depth $\WaveletDepth$.

\begin{pseudo}{low\_delay\_picture}{}
\bsCODE{\YTransform = initialise\_wavelet\_data(Y)}{\ref{wltinit}}
\bsCODE{\COneTransform = initialise\_wavelet\_data(C1)}{\ref{wltinit}}
\bsCODE{\CTwoTransform = initialise\_wavelet\_data(C2)}{\ref{wltinit}}
\bsCODE{ph=2^{\TransformDepth}*\left\lceil\frac{\LumaHeight}{2^{\TransformDepth}}\right\rceil}
\bsCODE{pw= 2^{\TransformDepth}*\left\lceil\frac{\LumaWidth}{2^{\TransformDepth}}\right\rceil}
\bsCODE{\SlicesX=pw//\SliceWidth}
\bsCODE{\SlicesY=ph//\SliceHeight}
\bsFOR{sy=0}{\SlicesY-1}
  \bsFOR{sx=0}{\SlicesX-1}
    \bsCODE{slice(sy, sx)}{\ref{sliceparsing}}
  \bsEND
\bsEND
\bsIF{is\_intra()}
    \bsCODE{intra\_dc\_prediction(\YTransform[0][\LL])}{\ref{intradcprediction}}
    \bsCODE{intra\_dc\_prediction(\COneTransform[0][\LL])}{\ref{intradcprediction}}
    \bsCODE{intra\_dc\_prediction(\CTwoTransform[0][\LL])}{\ref{intradcprediction}}
\bsEND
\end{pseudo}

Note that the padded dimensions are the padded luma dimensions. Since these are divisible 
by $2^\TransformDepth$ they are {\em a fortiori} divisible by the slice dimensions by 
the constraints of Section \ref{sliceparams}. 

Note also that intra DC coefficient prediction
occurs across all the wavelet coefficients, and in particular DC values on the edge of a slice
are predicted from DC values in previously decoded slices, which must be cached. 

\subsubsection{Slice parsing}
\label{sliceparsing}

This section specifies the operation of the $slice(sy,sx)$ process for parsing the slice with coordinates $(sx,sy)$. Each slice
contains coefficients from all subbands and components. Luma data is parsed first, followed by the chroma data, which
is interleaved. A length code allows the luma and chroma coefficients each to be terminated early, with remaining values
set to zero.

The overall slice decoding process is as follows:

\begin{pseudo}{slice}{sy,sx}
\bsCODE{slice\_bits\_left = \SliceBits}
\bsCODE{qindex=read\_nbits(7)}
\bsCODE{slice\_bits\_left -= 7}
\bsCODE{slice\_quantisers(qindex)}{\ref{slicequantisers}}
\bsCODE{length\_bits = \log_2(\SliceBits) }
\bsCODE{slice\_y\_length=read\_nbits(length\_bits)}
\bsCODE{slice\_bits\_left -= length\_bits}
\bsCODE{\ABitsLeft=slice\_y\_length}
\bsCODE{luma\_slice\_band(0,\LL,sy,sx,q_idx[0][\LL])}{\ref{lumasliceband}}
\bsFOR{level=1}{\WaveletDepth}
  \bsFOREACH{orient}{\HL,\LH,\HH}
    \bsCODE{luma\_slice\_band(level,orient,sy,sx)}{\ref{lumasliceband}}
  \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\bsCODE{slice\_bits\_left -= slice\_y\_length}
\bsCODE{\ABitsLeft=slice\_bits\_left}
\bsCODE{chroma\_slice\_band(0,\LL,sy,sx,q_idx)}{\ref{chromasliceband}}
\bsFOR{level=1}{\WaveletDepth}
  \bsFOREACH{orient}{\HL,\LH,\HH}
    \bsCODE{chroma\_slice\_band(level,orient,sy,sx)}{\ref{chromasliceband}}
  \bsEND
\bsEND
\bsCODE{flush\_inputb()}{\ref{blockreadbit}}
\end{pseudo}

\subsubsection{Setting slice quantisers}
\label{slicequantisers}

This section specifies how quantisers for individual subbands are determined from the quantisation matrix
and the quantisation index.

\begin{pseudo}{set\_band\_quantisers}{qindex}
\bsCODE{slice\_comp\_quantisers(Y,qindex)}
\bsCODE{slice\_comp\_quantisers(C1,qindex+\COneQuantOffset)}
\bsCODE{slice\_comp\_quantisers(C1,qindex+\CTwoQuantOffset)}
\end{pseudo}

\begin{pseudo}{slice\_comp\_quantisers}{c,qindex}
\bsCODE{q\_idx[c][\LL]=\max(qindex-\QuantMatrix[0][\LL],0)}
\bsFOR{level=1}{\WaveletDepth}
    \bsCODE{q\_idx[level][orient]=\max(qindex-\QuantMatrix[level][orient],0)}
\bsEND
\end{pseudo}

$C1$ and $C2$ quantiser index offsets are determined from the video format defaults and the picture header
as per Appendix \ref{videoformatdefaults}.

\subsubsection{Slice subband parsing}
\label{sliceband}

This section specifies the operation of the $luma\_slice\_band( level,orient,sy,sx)$ for 
parsing luma slice coefficients, and $chroma\_slice\_band( level,orient,sy,sx)$. for 
parsing chroma slice coefficients.
These coefficients populate areas of the coefficient data corresponding to the slice area.

\paragraph{Slice subband area\\}

The rectangular set of coefficients covered by a slice component ($Y$, $C1$ and $C2$) 
is demarcated by the values $left, right, top, bottom$, defined as fractions
of the subband dimensions (Section \ref{subbandwidthheight}):
\begin{eqnarray*}
  left & = & (subband\_width(level,c)*sx)//\SlicesX \\
  right & = & (subband\_width(level,c)*(sx+1))//\SlicesX \\
  bottom & = & (subband\_height(level,c)*sy)//\SlicesY \\
  top & = & (subband\_height(level,c)*(sy+1))//\SlicesY
\end{eqnarray*}

where $c=Y$ for luma coefficients, and $C1$ or $C2$ for chroma coefficients.

\paragraph{Luma slice subband data\\}
\label{lumasliceband}

\begin{pseudo}{luma\_slice\_band}{level, orient, sy, sx}
\bsFOR{y=bottom}{top-1}
  \bsFOR{x=left}{right-1}
    \bsITEM{\YTransform[level][orient]=0}{sintb}{\ref{segol}}
  \bsEND
\bsEND
\end{pseudo}

\paragraph{Chroma slice subband data\\}
\label{chromasliceband}

\begin{pseudo}{luma\_slice\_band}{level, orinet, sy, sx}
\bsFOR{y=bottom}{top-1}
  \bsFOR{x=left}{right-1}
    \bsITEM{\COneTransform[level][orient]=0}{sintb}{\ref{segol}}
    \bsITEM{\CTwoTransform[level][orient]=0}{sintb}{\ref{segol}}
  \bsEND
\bsEND
\end{pseudo}

\begin{informative*}
\subsection{Data adaption and application requirements}
\label{apps}

\end{informative*}